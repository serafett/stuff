\chapter{Custom Serialization}
Till so far all our examples have relied on standard Java serialization by letting the objects we store in Hazelcast, implement the java.io.Serializable interface. This mechanism is very generic and very easy to use, but it comes at a price:
\begin{enumerate}
\item lack of control on how the fields are serialized/deserialized.
\item suboptimal performance due to streaming class descriptors, versions, keeping track of seen objects to deal with cycles etc. This causes additional cpu load and suboptimal size of serialized data.
\end{enumerate}
That is why Hazelcast has an additional serialization mechanism based on the 'com.hazelcast.nio.serialization.Portable interface'. The Portable functionality replaces the DataSerializable that was part of Hazelcast 2, because the former performs better, supports versioning and is language/platform independent.

Serialization in Hazelcast works like this: when an object is placed in a Hazelcast data-structure, e.g. in a map or queue, Hazelcast first checks if it is an instance of String, Long, Integer, byte[], ByteBuffer, Date etc, since serialization for these types can be optimized. If that fails, it checks if it is an instance of DataSerializable and if that fails it will fall back on Java serialization or fails because the class isn't Serializable. [todo: this text needs to be updated for the Portable]

To demonstrate how Portable mechanism works, lets start with a simple Portable Person class: 
\begin{lstlisting}[language=java]
public class Person implements Portable {
    private String name;
    Person(){}
    public Person(String name) {
        this.name = name;
    }
    public int getClassId() {
        return PortableFactoryImpl.PERSON_CLASS_ID;
    }
    public void writePortable(PortableWriter writer) throws IOException {
        System.out.println("Serialize");
        writer.writeUTF("name", name);
    }
    public void readPortable(PortableReader reader) throws IOException {
        System.out.println("Deserialize");
        this.name = reader.readUTF("name");
    }
    public String toString() {
        return String.format("Person(name=%s)",name);
    }
}
\end{lstlisting}
As you can see the Portable interface is implemented. When a Person is serialized, the writePortable method is called and all fields are written to the PortableWriter. As you can see, the write of the name include the field name, making it possible to read particular fields without being forced to read all. When an object is deserialized, the readPortable method is called and the name field is read from the reader. Unlike the DataSerializable, the order in which fields are being read/written isn't important since reading/writing is based  on name. The last interesting method is the 'getClassId' which returns the identifier of that class; each Portable class needs to have a unique class id (a non zero value).

The next step is the 'PortableFactory' which is responsible for creating a new Portable instance based on the class id. In our case the implementation is very simple since we only have a single Portable class:
\begin{lstlisting}[language=java]
import com.hazelcast.nio.serialization.*;
public class PortableFactoryImpl implements PortableFactory {
    public final static int PERSON_CLASS_ID = 1;
    public Portable create(int classId) {
        switch (classId) {
            case PERSON_CLASS_ID: return new Person();
        }
        return new [TODO: Exception]
    }
}
\end{lstlisting}
But in practice the switch case probably will be a lot bigger. If an unmatched classId is encountered, an exception should be thrown [todo: which exception]. The cool thing about the PortableFactory is that object creation is pulled into userspace, so you control the initialization of the Portable instances. For example you could inject dependencies or you could even decide to move the construction of the Portable to a prototype bean in a Spring container. The last step is to connect the PortableFactory to the Hazelcast configuration:
\begin{lstlisting}[language=xml]
<serialization>
    <portable-factory-class>PortableFactoryImpl</portable-factory-class>
</serialization>
\end{lstlisting}
Of course we also want to see it in action:
\begin{lstlisting}[language=java]
public class PortableMember {
    public static void main(String[] args) {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance();
        Map<String, Person> map = hzInstance.getMap("map");
        map.put("Peter", new Person("Peter"));
        System.out.println(map.get("Peter"));
    }
}
\end{lstlisting}
When we run this PortableMember, we'll see the following output:
\begin{lstlisting}[language=java]
Serialize
Serialize
Deserialize
Person(name=Peter)
\end{lstlisting}
As you can see the Person is serialized when it is stored in the map and it is deserialized when it is read. You might ask why Serialize is called twice. This is because for every Portable class that is serialized for the first time, Hazelcast generates a new class that supports the serialization/deserialization process. 

The names of the fields are case sensitive and need to be valid java identifiers and therefor should not contains '.' or '-' for example. This is because the 

[todo: are field syntax (so naming)]

\section{Object traversal}
If a Portable, has a Portable field, the write and read operations need to be forwarded to that object. For example if we would add a DataSerializable address field to Person, the write and read operations of Person would look like this:
\begin{lstlisting}[language=java]
    public void writePortable(PortableWriter writer) throws IOException {
        writer.writeUTF("name", name);
        writer.writePortable("address", address);
    }
    public void readPortable(PortableReader reader) throws IOException {
        this.name = reader.readUTF("name");
        this.address = reader.readPortable("address");
    }
\end{lstlisting}
[todo: mapping complex non transportable object e.g. using serializable; consequence is that others can't read your stuff..]
[todo: what about object wrappers? I guess that there are some serializers registered for these types and the readPortable method can be used]
[todo: dealing with null, currently a NPE is thrown]

\section{Cycles}
One thing to look out for however are cycles between objects because it can lead to a stack overflow. Standard Java serialization protects against this, but since manual traversal is done in Portable objects, out of the box there is no protection. If this is an issue, you could store a map in a ThreadLocal that can be used to check for cycles.

\section{Subtyping}
Subtyping with the Portable functionality is easy, let every subclass have its own unique type id and add these id's to the switch/case in the PortableFactory so that the correct class can be instantiated. 

\section{Versioning}
In practice it can happen that multiple versions of same class are serialized and deserialized; imagine a Hazelcast client with an older Person class compared to the cluster. Luckily the Portable functionality supports versioning. In the configuration you can explicitly pass a version using the '<portable-version>' tag (defaults to 0):
\begin{lstlisting}[language=xml]
<serialization>
    <portable-factory-class>PortableFactoryImpl</portable-factory-class>
    <portable-version>1</portable-version>
</serialization>
\end{lstlisting}
When an Transportable instance is deserialized, next to the deserialized fields of that Portable also the class id and the portable-version will be stored. So every time you make a change to the class, the version should be incremented. 

Adding fields to a class is simple, removing fields can lead to problem if a new version of that class (with the removed field) is deserialized on a client which depends on that field. Although using the Portable interface is more work because of explicit mapping fields, it suffers less from field renaming, since name of the field in the class can be named independently of field name in the class. Another issue to watch out for is changing the field type, although although Hazelcast can do some basic type upgrading (e.g. int to long or float to double). 

Luckily Hazelcast provides access to the metadata of the to deserialize object through the PortableReader; the  version, available fields, the type of the fields etc can be retrieved. So you have full control on how the deserialization should take place. 

\section{TypeSerializers}
[todo: this section needs to be written; waiting for info from Mehmet]
\begin{lstlisting}[language=xml]
<serialization>
    <portable-factory-class>PortableFactoryImpl</portable-factory-class>
    <serializers>
    </serializers>
</serialization>
\end{lstlisting}

\section{Externalizable vs Portable}
The java.io.Externalizable can also be used for serialization/deserialization since it extends Serializable. So when Hazelcast defaults to the standard Java serialization mechanism, the Externalizable mechanism works without a problem. Although Externalizable provides more control compared to Serializable, it still isn't as flexible and performant as the Portable.

\section{serialVersionUID} 
When your class implements java.io.Serializable, make sure that it get a serialVersionUID. This prevents the JVM from calculating one on the fly and can lead to all kinds of class compatibility issues. In the examples they are not added to reduce space, but for production code there is no excuse.

\section{Good to know}

\emph{Caution}  Unlike the DataSerializable, the Portable functionality is allowed to call operations on Hazelcast that leads to new serialize/deserialize operations and doesn't run into StackOverflowErrors.

\section{What is next}
In this chapter java Serialization and the new Portable serialization functionality is explained. [todo: better what is next]