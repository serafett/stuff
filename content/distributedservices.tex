\chapter{Distributed Services}
Although Hazelcast is an excellent datagrid, one of the things I found missing was the ability to have transparently remote interfaces, similar as with RMI. With a remote interface, you get a proxy that implement that interface and deals with the remoting so you can pull out the remoting code out of your normal code. That is one of the reasons I started the Hazelblast project: https://github.com/pveentjer/Hazelblast.

Imagine we have an PersonService where we can create new persons and retrieve them based on an id:
\begin{lstlisting}[language=java]
public interface PersonService {
    void create(String id, String name);
    Employee get(String id);
}

import java.io.Serializable;
public class Person implements Serializable {
    public final String name;
    public final String id;
    public Person(String id, String name) {
        this.id = id;
        this.name = name;
    }
    public String toString() {
        return String.format("Person(id=%s,name=%s)",id,name);
    }
}
\end{lstlisting}

To allow the PersonService to be used in Hazelblast as a distributed service, we need to make some small modifications:
\begin{lstlisting}[language=java]
import com.hazelblast.client.annotations.*;
@DistributedService
public interface PersonService {
    @Partitioned
    void create(@PartitionKey String id, String name);
    @Partitioned
    Person get(@PartitionKey String id);
}
\end{lstlisting}
As you can see the changes are small, but very important. The first change is the addition of the @DistributedService annotation; this indicates that PersonService is a distributed service. You can also see that we added the @Partitioned annotation to the methods. This is to indicate that routing is done based on partitioning. And the last change is that the @PartitionKey is added to the 'id' arguments of the partitioned method. This is needed to indicate to the routing, that partitioning is done based on id. This is very important, since on the server side we are going to store persons based on their id, so we want to send the request to the right member. 

In some cases you don't want to route on the partition key argument itself but you want to route on a specific field. For example you want to route on the id of the Person object. This can be done by either letting the Person implement HazelcastInstanceAware and returning the id, or by specifying the 'property' on the @PartitionKey. When this property is specified, first an accessor method is tried and if that doesn't exist than direct field access is done.

A client of the PersonService can get hold of an instance using the ProxyProvider:
\begin{lstlisting}[language=java]
  ProxyProvider proxyProvider = new ProxyProviderImpl(hzInstance);
  PersonService personService = proxyProvider.getProxy(PersonService.class);
\end{lstlisting}
The proxyProvider returns an proxy that implements the EmployeeService interface, and routes requests to the right member based on the routing information we declared in the interface. Internally it wraps the method invocation in a Runnable and makes of the Hazelcast executor to send it to the correct machine.

Because the client can work with a simple interface, the complexities of remote calls are not intrusive in the code; although remoting still exists behind the scenes. So watch out for doing a lot of small calls because you don't want to have a chatty application. The proxy takes care of retrying in case of a member failure and is threadsafe, so it can safely be shared between threads. 

To complete the client side of the example; imagine that we have a client that creates an person and then gets it and prints it. The code would look something like this:
\begin{lstlisting}[language=java]
import com.hazelblast.client.ProxyProvider;
import com.hazelblast.client.impl.ProxyProviderImpl;
import com.hazelcast.config.Config;
import com.hazelcast.core.*;
import java.util.UUID;
public class Client {
    public static void main(String[] args) {
        Config config = new Config().setLiteMember(true);
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(config);
        ProxyProvider proxyProvider = new ProxyProviderImpl(hzInstance);
        PersonService personService = proxyProvider.getProxy(PersonService.class);
        String id = UUID.randomUUID().toString();
        personService.create(id, "foo");
        Person p = personService.get(id);
        System.out.println("Created: "+p);
        System.exit(0);
    }
}
\end{lstlisting}
If you want to use Spring on the client side to wire up the PersonService, I would suggest creating some FactoryBean that has access to a HazelcastInstance and ProxyProvider.

After creating the interface and the client, we still need to implement the PersonService for the server side. Luckily this is very straight forward:
\begin{lstlisting}[language=java]
import com.hazelcast.core.HazelcastInstance;
import java.util.Map;
public class PersonServiceImpl implements PersonService {
    private final Map<String, Person> personMap;
    public PersonServiceImpl(HazelcastInstance hzInstance) {
        this.personMap =hzInstance.getMap("persons");
    }
    public void create(String id, String name) {
        Person e = new Person(id, name);
        personMap.put(e.id, e);
    }
    public Person get(String id) {
        return personMap.get(id);
    }
}
\end{lstlisting}
The person are stored in the employeeMap with the id as key. 

Apart from having the PersonServiceImpl, we also need to wire it up on the server. This can be done using the SliceServer. Each SliceServer services a slice (so a set of all services running on a member).
\begin{lstlisting}[language=java]
import com.hazelblast.server.*;
import com.hazelblast.server.pojoslice.*;
import com.hazelcast.core.*;
public class Server {
    public static void main(String[] args){
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance();
        Pojo pojo = new Pojo(hzInstance);
        Slice slice = new PojoSlice(pojo);
        SliceServer sliceServer = new SliceServer(slice);
        sliceServer.start();
    }
    public static class Pojo implements HazelcastInstanceProvider {
        @Exposed
        public final PersonService personService;
        private final HazelcastInstance hzInstance;

        public Pojo(HazelcastInstance hzInstance) {
            this.hzInstance = hzInstance;
            this.personService = new PersonServiceImpl(hzInstance);
        }
        public HazelcastInstance getHazelcastInstance() {
            return hzInstance;
        }
    }
}
\end{lstlisting}[language=java]
The PojoSlice receives a POJO where the services that are allowed to be exposed need to be annotated with the @Exposed annotation, this is to reduce security risks. The SliceServer can be embedded but can also be run standalone. The Slice implementation used here is the PojoSlice, but there also is a Spring Slice available so you can wire up your services to Spring. If you want you can create your own Slice implementation, e.g. using Guice.

If you want you can add the sources of the API, the client and the server in a single module. But in a lot of cases this is unwanted because you don't want to expose the server implementations to the client. That is why it is a good idea separate:
\begin{enumerate}
\item API module: containing the service interfaces and the POJO's.
\item The Server Module: containing the actual implementation of the services
\end{enumerate}
The API module can then be shared with clients without them needing to rely on the server sources.

\section{Load Balancing}
In the PersonService we rely on partitioning the route a request to the correct machine. But sometimes you don't care where a request is routed to, as long as it is send to some machine. For these situations there is a different routing mechanism available that relies on load balancing. To use it, add the @LoadBalanced annotation. For example, we have some kind of Echo Service, where an message is send to an arbitrary member in the cluster:
\begin{lstlisting}[language=java]
import com.hazelblast.client.annotations.*;
@DistributedService
public interface EchoService {
    @LoadBalanced
    void echo(String text);
}
\end{lstlisting}
By default a RoundRobinLoadBalancer implementation is used, but you can create your own by specifying the loadBalancer property on the @LoadBalanced annotation. You could for example create one that load-balances based on heap/cpu-load of the members. 

In the future other routing mechanisms are going to be added; the most important one is the @ForkJoin that forks a request to all partitions and merges the results.

\section{DTO}
The Person object that is returned by the PersonService has multiple purposes:
\begin{enumerate}
\item internally it is used as domain object and although we currently we don't have any domain logic, in practice there often is.
\item externally it is used to exchange information between client and server.
\end{enumerate}
But using the same object for multiple purposes can lead to a lot of problems and it will start to show when your domain becomes more complex. The cause is a tight coupling between the client and the server; so the client will know about the implementation details of the server and therefor they can't be developed independently. 

To solve this problem, it often is a good practice to use Data Transfer Objects (DTO's), thereby hiding the domain objects to the client. Often the DTO's and the domain object will have a lot of similarities; the name, the fields, so it can feel like a lot of duplication. But that is the price that needs to be payed for loose coupling. But you get gain a lot of freedom; the client will only need to see the field you want it to see, it makes versioning of remote interfaces a lot easier. 

Another good usecase for DTO's is bundling multiple smaller requests into a single call and returning a DTO containing the results for the bundled calls.

\section{Timeout}
When a remote method is called, the client will block till the call completes. By default all remote method are called with a timeout of 60 seconds. When a timeout happens a DistributedMethodTimeoutException is thrown. The timeout can be configured using the timeout argument on the @LoadBalanced or @Partitioned annotation. By default, the Hazelcast Executor task, executing the remote method invocation, will be interrupted. Although it depends on the logic executed inside th task if it checks the interrupt status. If you do not want this task to be interrupted, you can set the 'interruptOnTimeout' attribute on the @LoadBalanced and @Partitioned annotation to false.

\section{Exceptions}
With an interface that implements the @DistributedService you are not forced to have the methods throw certain remoting exceptions. That would bring back nasty memories from RMI. So you can declare any Exception, checked or unchecked, on your methods. 

To help you with debugging, the stacktrace of a remotely thrown exception is modified. Normally that stacktrace only include the callstack on the serverside, but the proxy modifies it so that the clientside stacktrace is appended. This really helps to figure out what went wrong on the server and the client side.

[todo: creation]

\section{What is next}

