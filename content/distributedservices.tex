\chapter{Distributed Services}
Although Hazelcast is an excellent datagrid, one of the things I found missing was the ability to have transparently remote interfaces, similar as with RMI. So you can call an interface, which acts as a proxy and forwards the call to the right machine. That is why I started the Hazelblast project: https://github.com/pveentjer/Hazelblast that takes care of this.

Image we have an PersonService where we can create new persons and retrieve them based on an id. So the interface would look something like:
\begin{lstlisting}[language=java]
public interface PersonService {
    void create(String id, String name);
    Employee get(String id);
}

import java.io.Serializable;
public class Person implements Serializable {
    public final String name;
    public final String id;
    public Person(String id, String name) {
        this.id = id;
        this.name = name;
    }
    public String toString() {
        return String.format("Person(id=%s,name=%s)",id,name);
    }
}
\end{lstlisting}

To allow the PersonService to be used in Hazelblast as a remote service, we need to do some modifications:
\begin{lstlisting}[language=java]
import com.hazelblast.client.annotations.*;
@DistributedService
public interface PersonService {
    @Partitioned
    void create(@PartitionKey String id, String name);
    @Partitioned
    Person get(@PartitionKey String id);
}
\end{lstlisting}
As you can see the changes are small, but very important. First we added the @DistributedService annotation, to indicates that PersonService is a distributed service. You can also see that we @Partitioned annotation to the methods. This is to indicate that routing is done based on partitioning. And the last change is that the @PartitionKey is added to the 'id' arguments of the partitioned method. This is needed to indicate to the routing, that partitioning is done based on id. This is very important, since on the server side we are going to store persons based on their id, so we want to send the request to the right member. 

In some cases you don't want to route on the partition key argument itself but you want to route on a specific field. For example you want to route on the id of the Person object. This is possibly by either letting the Person implement HazelcastInstanceAware and returning real partition key, or by specifying the 'property' on the @PartitionKey. When this property is specified, first an accessor method is tried and if that doesn't exist than direct field access is done.

A client of the PersonService can get hold of an instance using the ProxyProvider:
\begin{lstlisting}[language=java]
  ProxyProvider proxyProvider = new ProxyProviderImpl(hzInstance);
  PersonService personService = proxyProvider.getProxy(PersonService.class);
\end{lstlisting}
The proxyProvider returns an proxy that implements the EmployeeService interface that routes requests to the right member based on the routing information we declared in the interface and internally relies on the Hazelcast Executor. 

Because the client can work with a simple interface, the complexities of remote calls are not intrusive in the code; although remoting still exists behind the scenes. So watch out for doing a lot of small calls because you don't want to have a chatty application. The proxy takes care of retrying in case of a member failure and is threadsafe, so can safely be shared between threads. 

To complete the client side of the example; imagine that we have a client that creates an employee and then gets it and prints it. The code would look something like this:
\begin{lstlisting}[language=java]
import com.hazelblast.client.ProxyProvider;
import com.hazelblast.client.impl.ProxyProviderImpl;
import com.hazelcast.config.Config;
import com.hazelcast.core.*;
import java.util.UUID;
public class Client {
    public static void main(String[] args) {
        Config config = new Config().setLiteMember(true);
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(config);
        ProxyProvider proxyProvider = new ProxyProviderImpl(hzInstance);
        PersonService personService = proxyProvider.getProxy(PersonService.class);
        String id = UUID.randomUUID().toString();
        personService.create(id, "foo");
        Person p = personService.get(id);
        System.out.println("Created: "+p);
        System.exit(0);
    }
}
\end{lstlisting}
If you want to use Spring on the client side to wire up the PersonService, I would suggest creating some FactoryBean that has access to a HazelcastInstance and ProxyProvider.

After creating the interface and the client, we still need to implement the PersonService for the server side. Luckily this is very straight forward:
\begin{lstlisting}[language=java]
import com.hazelcast.core.HazelcastInstance;
import java.util.Map;
public class PersonServiceImpl implements PersonService {
    private final Map<String, Person> personMap;
    public PersonServiceImpl(HazelcastInstance hzInstance) {
        this.personMap =hzInstance.getMap("persons");
    }
    public void create(String id, String name) {
        Person e = new Person(id, name);
        personMap.put(e.id, e);
    }
    public Person get(String id) {
        return personMap.get(id);
    }
}
\end{lstlisting}
The person are stored in the employeeMap with the id as key. 

Apart from having the PersonServiceImpl, we also need to wire it up on the server. This can be done using the SliceServer. Each SliceServer services a slice (so a set of all services running on a member).
\begin{lstlisting}[language=java]
import com.hazelblast.server.*;
import com.hazelblast.server.pojoslice.*;
import com.hazelcast.core.*;
public class Server {
    public static void main(String[] args){
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        Pojo pojo = new Pojo(hzInstance);
        Slice slice = new PojoSlice(pojo);
        SliceServer sliceServer = new SliceServer(slice);
        sliceServer.start();
    }
    public static class Pojo implements HazelcastInstanceProvider {
        @Exposed
        public final PersonService personService;
        private final HazelcastInstance hzInstance;

        public Pojo(HazelcastInstance hzInstance) {
            this.hzInstance = hzInstance;
            this.personService = new PersonServiceImpl(hzInstance);
        }
        public HazelcastInstance getHazelcastInstance() {
            return hzInstance;
        }
    }
}
\end{lstlisting}[language=java]
The PojoSlice receives a POJO where the services that are allowed to be exposed need to be annotated with the @Exposed annotation, this is to reduce security risks. The SliceServer can be embedded but can also be run standalone. The Slice implementation used here is the PojoSlice, but there also is a Spring Slice available so you can wire up your services to Spring. If you want you can create your own Slice implementation, e.g. using Guice.

If you want you can add the sources of the API, the client and the server in a single module. But in a lot of cases this is unwanted because you don't want to expose the server implementations to the client. That is why it is a good idea separate:
\begin{enumerate}
\item API module: containing the service interfaces and the POJO's.
\item The Server Module: containing the actual implementation of the services
\end{enumerate}
The API module can then be shared with clients without them needing to rely on the server sources.

\section{Distributing non distributable objects}

\section{Load Balancing}
In the PersonService we rely on partitioning the route a request to the correct machine. But sometimes you don't care where a request is routed to, as long as it is send to some machine. For these situations there is a different routing mechanism available that relies on load balancing. To use it, add the @LoadBalanced annotation. For example, we have some kind of Echo Service, where an message is send to an arbitrary member in the cluster:
\begin{lstlisting}[language=java]
import com.hazelblast.client.annotations.*;
@DistributedService
public interface EchoService {
    @LoadBalanced
    void echo(String text);
}
\end{lstlisting}
By default a RoundRobinLoadBalancer implementation is used, but you can create your own by specifying the loadBalancer property on the @LoadBalanced annotation. You could for example create one that loadbalances based on heap/cpu load of the members. 

In the future other routing mechanisms are going to be added; the most important one is the @ForkJoin that forks a request to all partitions and merges the results.

\section{DTO}
The Person object that is returned by the PersonService is a very basic object that is used for client/server communication, and also used internally in the PersonServiceImpl. In practice your objects are going to be a lot more complex. That prevent a tight coupling between the client and the server, we don't want the client to know about implementation details on the server, and therefor we don't want to expose our domain objects to the clients. Therefor it is best to create a Data Transfer Object (DTO). In a lot of cases they will look a lot like the domain objects, but they are designed to be exposed and go over the line. 

\section{Timeout}
By default all remote method are called with a timeout of 60 seconds. When the timeout happens, a DistributedMethodTimeoutException is thrown. The timeout can be configured using the timeout argument on the @LoadBalanced or @Partitioned annotation. By default task executing the remote method invocation will be interrupted, although it depends on that task of course it is responsive to the interrupt status. If you do not want this task to be interrupted, you can set the 'interruptOnTimeout' attribute on the @LoadBalanced and @Partitioned annotation.

\section{Exceptions}
With an interface that implements the @DistributedService you are not forced to have the methods throw certain exceptions. That would bring back nasty memories from RMI. So you can declare any exception, checked or unchecked, on your methods. 

To help you with debugging, the stacktrace of a remotely thrown exception is modified. Normally that stacktrace only include the callstack on the serverside, but the proxy modifies it so that it includes the client side stacktrace as well. This really helps a lot to figure out what has gone wrong.

Currently Spring/POJO support.

interruptOnTimeout
[todo: creation]

\section{What is next}

