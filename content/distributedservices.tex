\chapter{Distributed Services}
Although Hazelcast is an excellent datagrid, one of the things I found missing was the ability to have 
\begin{enumerate}
\item: transparent remote interface
\item: the ability 
\end{enumerate}

That is why project was started Hazelcast.

Image we have an EmployeeService where we can create new employees and retrieve them based on an id. So the interface would look something like:
\begin{lstlisting}[language=java]
public interface EmployeeService {
    void create(String id, String name);
    Employee get(String id);
}
\end{lstlisting}
One of the main features of Hazelblast is that clients can call interfaces to distributed services; where the actual service implementation is living on a different JVM. To make the EmployeeService a distributed service, we do the following: 
\begin{lstlisting}[language=java]
import com.hazelblast.client.annotations.*;
@DistributedService
public interface EmployeeService {
    @Partitioned
    void create(@PartitionKey String id, String name);
    @Partitioned
    Employee get(@PartitionKey String id);
}
\end{lstlisting}
As you can see the changes are small, but very important. First we added the @DistributedService annotation, to indicate that this is a distributed service. And you can also see that we @Partitioned annotation to the methods. This is to indicate that routing is done based on partitioning. Another thing we can see is that the @PartitionKey is added to the 'id' arguments. This is needed to indicate to the routing, that partitioning is done based on this particular id. This is very useful, since on the server side we are going to store employees based on their id, so we immediately send to request to the right machine. 

A client of the EmployeeService can get hold of an instance using the ProxyProvider:
\begin{lstlisting}[language=java]
  ProxyProvider proxyProvider = new ProxyProviderImpl(hzInstance);
  EmployeeService employeeService = proxyProvider.getProxy(EmployeeService.class);
\end{lstlisting}
The proxyProvider returns an proxy that implements the EmployeeService interface that routes requests to the right member based on the routing information we declared in the interface. Internally the Hazelcast Executor is used for this. Because the client can work with a simple interface, the complexities of remote calls are not intrusive in the code; although remoting still exists behind the scenes.

So finish the client example; imagine that we have a client that creates an employee and then gets it and prints it. The code would look something like this:
\begin{lstlisting}[language=java]
import com.hazelblast.client.ProxyProvider;
import com.hazelblast.client.impl.ProxyProviderImpl;
import com.hazelcast.config.Config;
import com.hazelcast.core.*;
import java.util.UUID;
public class Client {
    public static void main(String[] args) {
        Config config = new Config();
        config.setLiteMember(true);
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(config);
        ProxyProvider proxyProvider = new ProxyProviderImpl(hzInstance);
        EmployeeService employeeService = proxyProvider.getProxy(EmployeeService.class);
        String id = UUID.randomUUID().toString();
        employeeService.create(id,"foo");
        Employee e = employeeService.get(id);
        System.out.println("Created: "+e);
        System.exit(0);
    }
}
\end{lstlisting}
If you want to use Sprint on the client side to wire up the EmployeeService, I would suggest creating some FactoryBean that has access to a HazelcastInstance and creates a proxy using the ProxyProvider.


timeout
The proxy also takes care of failover
DTO
exception are sum of client + remote side stacktrace
tip: create a separate module where the interace is defined.. and share them between client/server

And on the Server it can be implemented like this:
\begin{lstlisting}[language=java]
import com.hazelcast.core.HazelcastInstance;
import java.util.Map;
public class EmployeeServiceImpl implements EmployeeService {
    private final Map<String, Employee> customerMap;
    public EmployeeServiceImpl(HazelcastInstance hzInstance) {
        this.customerMap =hzInstance.getMap("customers");
    }
    public void create(String id, String name) {
        Employee e = new Employee(id, name);
        customerMap.put(e.id, e);
        System.out.printf("Employee %s with id %s and name %s created\n",
                name, e.id, name);
    }
    public Employee get(String id) {
        return customerMap.get(id);
    }
}

\end{lstlisting}

\section{Distributing non distributable objects}

\section{Load Balancing}
In the EmployeeExample we rely on partitioning the route a request to the correct machine. But sometimes you don't care where a request is routed to, as long as it is routed. For these situation the @LoadBalanced annotation can be used. For example, we have some kind of Echo Service, where an echo is send to an arbitrary element in the cluster:
\begin{lstlisting}[language=java]
import com.hazelblast.client.annotations.*;
@DistributedService
public interface EchoService {
    @LoadBalanced
    void echo(String text);
}
\end{lstlisting}
By default a RoundRobinLoadBalancer implementation is used, but you can create your own. You could for example create one that loadbalances based on heap/cpu load of the members. 

In the future other routing mechanisms are going to be added; the most important one is the @ForkJoin that forks a request to all partitions and merges the results.

\section{DTO}
The Person object that is returned by the EmployeeService is a very basic object that is used for client/server communication, and also used internally in the EmployeeServiceImpl. In practice your objects are going to be a lot more complex. That prevent a tight coupling between the client and the server, we don't want the client to know about implementation details on the server, it is best to create Data Transfer Objects. In a lot of cases the will look a lot like the domain objects used inside of the service implementation, but they are designed to be exposed and go over the line. 

\section{Timeout}
By default all remote method are called with a timeout of 60 seconds. When the timeout happens, a DistributedMethodTimeoutException is thrown. The timeout can be configured using the timeout argument on the @LoadBalanced or @Partitioned annotation. By default also task on the server is interrupted, although it depends on that task if the Thread will listen to its interrupt status. Turning off this interrupt behavior, can be done using the 'interruptOnTimeout' attribute on the @LoadBalanced and @Partitioned annotation.

\section{Exceptions}
With an interface that implements the @DistributedService you are not forced to have the methods throw certain exceptions. That would bring back nasty memories from RMI. So you can declare any exception, checked or unchecked, on your methods. 

To help you with debugging, the stacktrace of a remotely thrown exception is modified. Normally that stacktrace only include the callstack on the serverside, but the proxy modifies it so that it includes the client side stacktrace as well. This really helps a lot to figure out what has gone wrong.

Currently Spring/POJO support.

interruptOnTimeout
[todo: creation]

\section{What is next}

