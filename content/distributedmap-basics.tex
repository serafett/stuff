\chapter{Distributed Map Basics}

In this chapter, we'll learn how to use one of the most important data structures for distributed applications; the distributed map. A few of the differences between an ordinary map and a distributed map in Hazelcast
\begin{enumerate}
\item scalable; so just add or remove machine when needed to match the required capacity.
\item high availability; so if a machine crashes, a different machine can take over. 
\end{enumerate}
This makes the distributed map the ideal workhorse to write distributed applications.

The HazelcastMap implements the java.collections.Map interface, so replacing an ordinary map implementation by the Hazelcast version, doesn't need to be a complex operation and also programmers will be up to speed quickly.

TODO: ConcurrentMap operations never throw java.util.ConcurrentModificationException. Add somewhere.

TODO: Give some idea about capacity in production.. number of entries... total size.

\begin{enumerate}
\item Reading/Writing
\item Custom Keys
\item Query API
\item Concurrency Control
\item MultiMap
\item ManyMap
\end{enumerate}

\section{Reading/Writing}
Because the HazelcastMap implements the Map interface, putting entries and retrieving them is very simple since you can use operators use normally use when you deal with the map like get/put etc. Here is a small example where you can see 2 members; in the put member an item is placed in the map, and in the get member it is retrieved.

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.util.Map;
public class PutMember {
    public static void main(String[] args) {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        Map<String, String> map = hzInstance.getMap("map");
        map.put("1", "Tokyo");
    }
}

import com.hazelcast.core.*;
import java.util.Map;
public class GetMember {
    public static void main(String[] args) {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        Map<String, String> map = hzInstance.getMap("map");
        System.out.println(map.get("1"));
    }
}
\end{lstlisting}

\section{Custom Keys}
My experience is that in most cases when you work with a Hazelcast map you will make use of a Long, Integer or String as key. But in some cases you will need to create custom keys, but to do it correctly in Hazelcast, you need to understand how this works. 

When you store a key/value in a Hazelcast map, the actual objects are not stored in the map because an object can't move from one JVM to another. Instead the key/value are serialized to byte-arrays and these will be stored in a local ConcurrentHashMap. So the Hazelcast map will not make use of the hashcode/equals of your object, but of the byte array versions of your object. That is why you need to make sure that equal keys result in equal byte arrays. 

Below is an example of a key implementation that is valid if you use it as key in a normal HashMap, but stops working when it is used as a key in a Hazelcast map:
\begin{lstlisting}[language=java]
public final class BrokenKey implements Serializable {
    private final String significant;
    private final String insignificant;
    public BrokenKey(String significant, String insignificant) {
        this.significant = significant;
        this.insignificant = insignificant;
    }
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof BrokenKey)) return false;
        BrokenKey that = (BrokenKey) o;
        return that.significant.equals(this.significant);
    }
    public int hashCode() {
       return significant.hashCode();
   }
}
\end{lstlisting}
Although equals and hashCode are implemented correctly; equal object should result in the same hashCode. In this case equals and hashCode are both based solely on the significant field. So if you have 2 keys:
\begin{verbatim}
BrokenKey key1 = new BrokenKey("a","b");
BrokenKey key2 = new BrokenKey("a","c");
\end{verbatim} 
Then 'key1.equals(key2)' and 'key1.hashCode()==key2.hashCode()' is true. But since the byte-array content of both objects is different, this key implementation should not be used with a Hazelcast map.

TODO:
Note that the distributed Set and List stores its entries as the keys in a distributed Map. So the notes above apply to the objects you store in Set and List.

\section{Hazelcast Query API}

To explain the Hazelcast Query API we'll begin with a naive example; retrieving all customers with the given name.

\begin{verbatim}
public Set<Customer> getWithName(String name){
    Set<Customer> result = new HashSet<Customer>();
    for(Customer customer: customerMap.values()){
        if(customer.getName().equals(name))
           result.add(customer);
    }
    return result;
}
\end{verbatim}

Although the code is simple it contains a few problems:
\begin{enumerate}
\item Not parallelizable: One node will iterate over all customers; imagine that there are millions of customers. So this approach doesn't make use of the computing capacity of the machines.
\item Inefficient: all customers need to be pulled into memory, so need to be deserialized before a single field is read and then the object is discarded. 
\end{enumerate}

Luckily Hazelcast solves these problems by supporting distributed queries using 2 different mechanisms:
\begin{enumerate}
\item Criteria API
\item Distributed SQL Query
\end{enumerate}

\subsection{Criteria API}

The distributed version looks like this:

\begin{verbatim}
public Set<Customer> getWithName(String name){
    EntryObject e = new PredicateBuilder().getEntryObject();
    Predicate predicate = e.get("name").equals(name);
    return (Set<Customer>) customerMap.values(predicate);
}
\end{verbatim}

Explain EntryObject, Predicate.

\subsection{Distributed SQL Query}
It also is possible instead of using the programmatic api to create a query, to use a more SQL like language:

\begin{verbatim}
public Set<Customer> getWithName(String name){
    Predicate predicate = new SqlPredicate(String.format("name = %s",name));
    return (Set<Customer>) customerMap.values(predicate);
}
\end{verbatim}

supported SQL syntax:
TODO: Is it case sensitive?

\subsubsection{AND/OR}
<expression> AND <expression> AND <expression>...
\begin{enumerate}
\item active AND age>30
\item active=false OR age = 45 OR name = 'Joe'
\item active AND (age >20 OR salary < 60000)
\end{enumerate}

\subsection{=, !=, <, <=, >, >=}
<expression> = value
\begin{enumerate}
\item age <= 30
\item name ="Joe"
\item salary != 50000
\end{enumerate}

\subsubsection{BETWEEN}
<attribute> [NOT] BETWEEN <value1> AND <value2>

\begin{enumerate}
\item age BETWEEN 20 AND 33 (same as age >=20 AND age<=33)
\item age NOT BETWEEN 30 AND 40 (same as age <30 OR age>40)
\end{enumerate}

%\subsection{LIKE}
%<attribute> [NOT] LIKE 'expression'
% (percentage sign) is placeholder for many characters, _ (underscore) is placeholder for only one character.
%\begin{enumerate}
%\item name LIKE 'Jo%' (true for 'Joe', 'Josh', 'Joseph' etc.)
%\item name LIKE 'Jo_' (true for 'Joe'; false for 'Josh')
%\item name NOT LIKE 'Jo_' (true for 'Josh'; false for 'Joe')
%\item name LIKE 'J_s%' (true for 'Josh', 'Joseph'; false 'John', 'Joe')
%\begin{enumerate}

\subsubsection{IN}
<attribute> [NOT] IN (val1, val2, ...)
\begin{enumerate}
\item age IN (20, 30, 40)
\item age NOT IN (60, 70)
\end{enumerate}

\section{Concurrency Control}
The Hazelcast map itself is threadsafe just like the ConcurrentHashMap or the Collections.synchronizedMap, but in some cased your threadsafety requirements are bigger than what hazelcast provides out of the box. Luckily Hazelcast provides multiple concurrency contorl solutions;  it can either be pessimistic using locks or optimistic using compare and swap operations. Todo: what about transactions?

Take a look at the following example; if run by multiple members in parallel the total amount would be 
\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.io.Serializable;
public class RacyUpdateMember {
    public static void main(String[] args) throws Exception {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        IMap<String, Value> map = hzInstance.getMap("map");
        String key = "1";
        map.put(key, new Value());
        System.out.println("Starting");
        for (int k = 0; k < 1000; k++) {
            if(k%100 == 0)System.out.println("At: "+k);
            Value value = map.get(key);
            Thread.sleep(10);
            value.field++;
            map.put(key, value);
        }

        System.out.println("Finished! Result = " + map.get(key).field);
    }
    static class Value implements Serializable {
        public int field;
    }
}
\end{lstlisting}[language=java]

\subsection{Pessimistic Locking}
The classic way to solve the race problem is to use a lock. In Hazelcast there are various ways to lock, but for this example we'll use the locking functionality provided by the map using the map.lock/map.unlock methods.

Todo: are these reentrant?
todo: are these fair?
also the regular locking rules apply, don't lock too long, don't lock too much.

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.io.Serializable;
public class PessimisticUpdateMember {
    public static void main(String[] args) throws Exception {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        IMap<String, Value> map = hzInstance.getMap("map");
        String key = "1";
        map.put(key, new Value());
        System.out.println("Starting");
        for (int k = 0; k < 1000; k++) {
            map.lock(key);
            try {
                Value value = map.get(key);
                Thread.sleep(10);
                value.field++;
                map.put(key, value);
            } finally {
                map.unlock(key);
            }
        }
        System.out.println("Finished! Result = " + map.get(key).field);
    }
    static class Value implements Serializable {
        public int field;
    }
}
\end{lstlisting}

Another way to lock is to acquire some predictable Lock object from Hazelcast. You could give every value its own lock, but you could also create a stripe of locks. Although it potentially can increase contention, it will reduce space.

todo: when a key is locked, it still is possible to do a read, but not to do a write.

\subsection{Optimistic Locking}
TODO: Does optimistic rely on a lock or is truly using cas?

It is important to implement equals on the value, because this is used to determine of 2 objects are equal. With the ConcurrentHashMap it is based on object reference. On the keys the byte-array equals is used, but on the replace(key,oldValue,newValue) the equals is used. If you fail to forget it, your code will not work!

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.io.Serializable;
//This code is broken on purpose.
public class OptimisticMember {
    public static void main(String[] args) throws Exception {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        IMap<String, Value> map = hzInstance.getMap("map");
        String key = "1";
        map.put(key, new Value());
        System.out.println("Starting");
        for (int k = 0; k < 1000; k++) {
            if(k%10==0) System.out.println("At: "+k);
            for (; ; ) {
                Value oldValue = map.get(key);
                Value newValue = new Value(oldValue);
                //   Thread.sleep(10);
                newValue.field++;
                if(map.replace(key, oldValue, newValue))
                    break;
            }
        }
        System.out.println("Finished! Result = " + map.get(key).field);
    }
    static class Value implements Serializable {
        public int field;
        public Value(){}
        public Value(Value that) {
            this.field = that.field;
        }
        public boolean equals(Object o){
            if(o == this)return true;
            if(!(o instanceof Value))return false;
            Value that  = (Value)o;
            return that.field == this.field;
        }
    }
}
\end{lstlisting}
Aba problem; it can be that the following thing happens. And explain how it can be solved by adding a version; although all the other fields will be equal, the version field will prevent objects from being seen as equal.

\subsection{Pessimistic vs Optimistic}
TODO: When to choose one, when to choose the other. Normally optimistic performs better if there is not that much contention. What is the reason to do so in Hazelcast? Is it better performing?

\section{MultiMap}
In some cases you need to attach multiple values for a single key. Luckily Hazelcast provides out of the box functionality for that in the form of a MultiMap. The MultiMap doesn't implement the java.util.Map interface since the signatures of the method are different. The MultiMap does have support for most of the functionality provided by the IMap (so locking, listeners etc). But it doesn't support indexing.

The reason why the MultiMap exists, apart from being easy to use is efficiency. If you would use the hazelcast map with an ordinary collection as value, then you need to deserialize the whole collection for every operation you do on that collection (e.g. adding a single element). With the MultiMap this isn't needed, so it is a lot more efficient.

To demonstrate the MultiMap where are going to create 2 member; in one member dummy data is created and in the other member it is read and written to the console.
\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
public class PutMember {
    public static void main(String[] args){
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        MultiMap<String,String> map = hzInstance.getMultiMap("map");
        
        map.put("Peter","England");
        map.put("Peter","Holland");
        map.put("Talip","Turkey");
    }
}
\end{lstlisting}

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.util.Collection;
public class PrintMember {
    public static void main(String[] args) {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        MultiMap<String,String> map = hzInstance.getMultiMap("map");
        for(String key: map.keySet()){
            Collection<String> values = map.get(key);
            System.out.printf("%s -> %s\n",key,values);
        }
    }
}
\end{lstlisting}

It is important to realize that map.get(key) returns a copy of the values at some moment in time. Changes to this collection will result in an a UnsupportedOperationException. So if you want to change the values, you need to do it through the map.remove methods.

Removing items; you can remove items from the MultiMap. This is using the equals operator of the value. If the collection for a specific key is empty, this collection will not automatically be removed, so it can be that you need to clean up the MultiMap so that no empty value collections remains.

Hash/equals: (verified with tests)
The key doesn't need to implement hash/equals, its byte-array content will be used
The value needs to implement equals, its equals will be used

The value collection is set based, so no duplicates and there is no ordering.Null value is not allowed (npe). But the MultiMap can also be configured to be list based: MultiMapConfig.setValueCollectionType(ValueCollectionType.LIST). 

One thing worth knowing; if a value collection with K is stored on member1 because K is owned by that member1, and member2 does a map.get(K), then the whole collection will transported from member1 to member 2. So if that value collection is big, it could lead to performance problems. A solution would be to send the whole operation to member1, so send the logic to the data instead of the data to the logic.


\section{Gotcha's}

When Map.entrySet(), Map.keySet() or Map.values() is called, a snapshot of the current state of the map is returned. Changes that are made in the map, so not reflect into changes these maps. Also when changes are made on these collections, an UnsupportedOperationException is thrown.

Changes made on keys/values after they have been persisted, will not reflect in changes in the map. This is because not the key/value object themselves are stored, but their serialized version. So the following idiom is broken:
\begin{lstlisting}[language=java]
Employee e = employeeMap.get("123");
e.fire();
\end{lstlisting}
If you want the changes in e to be published, you need to write e back to the map.

TODO: What about cache where serializion for local object is 'skipped?

\section{What is next}
In this chapter a lot of the basic operations on the Distributed Map were explained. In the next chapter we'll cover more advanced features.







