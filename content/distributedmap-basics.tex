\chapter{Distributed Map Basics}

In this chapter, we'll learn how to use one of the most important data structures for distributed applications; the distributed map. A few of the differences between an ordinary map and a distributed map in Hazelcast
\begin{enumerate}
\item scalable; so just add or remove machine when needed to match the required capacity.
\item high availability; so if a machine crashes, a different machine can take over. 
\end{enumerate}
This makes the distributed map the ideal workhorse to write distributed applications.

The HazelcastMap implements the java.collections.Map interface, so replacing an ordinary map implementation by the Hazelcast version, doesn't need to be a complex operation and also programmers will be up to speed quickly.

\section{Reading/Writing}
Because the HazelcastMap implements the Map interface, putting entries and retrieving them is very simple:

\begin{verbatim}
public class Node{
    public static void main(String[] args){
       Map<String,String> map = Hazelcast.getMap("map");
       map.put("1","Tokyo");
       map.put("2","Berlin");
       System.out.println(map.get("1"));
       System.out.println(map.get("2"));
    }
}
\end{verbatim}
In this example you can see that after the map has been retrieved, first 2 put operations are done followed by 2 get operations. 

But for this chapter I want to give a more realistic example, we'll start with a  very basic CRUD customer service where customers can be created and where existing customers can be retrieved based on the customer id.

First we create the entity Customer POJO. 
\begin{verbatim}
public class Customer implements Serializable{
  private final String id = UUID.randomUUID().toString();
  private String name;
  public Customer(String name){this.name = name;}
  public String getId(){return id;}
  public String getName(){return name;}
  public void setName(String newName){this.name = newName;}
}
\end{verbatim}

The Customer class implements the Serializable interface because the Customer objects are going to be stored in a Hazelcast distibuted map. Hazelcast can use different serialization mechanisms, so you are not tied to java serialization (todo: reference to serialization explanation/topic), but for this chapter we are going to stick to java serialization. For brevity reasons the serialVersionUID is not added to all Serializable implementations. For production code however it is a good practice since serialized objects can be stored for a long time and the class structures can change over time. 

Hazelcast doesn't impose any design limitations, so there are no interfaces to implement or certain naming conventions to follows (e.g. Java Beans). You are completely in charge of your object design.

Now we have implemented the Customer, we can get started with the implementation of a Customer Service. We'll start simple with 2 operations:
\begin{enumerate}
\item creation of a customer
\item retrieval of existing customers based on the customer id
\end{enumerate}

The Java code for this Customer Service looks like this:

\begin{verbatim}
public class CustomerService{
  private final Map<String,Customer> customerMap = Hazelcast.getMap("customers");
  
  public String create(String name){
    Customer c = new Customer(name);
    customerMap.put(c.getId(), customer);
    System.out.printf(
      "Customer %s with id %s and name %s created\n",
        name,c.getId(),name);
    return customer.getId();
  }
  
  public Customer get(String id){
    return customerMap.get(id);
  } 
}

public class Main{
  public static void main(String[] args){
    CustomerService customerService = new CustomerService();
    customerService.create("john");
  }
}
\end{verbatim}

The customerMap is retrieved from Hazelcast by calling Hazelcast.getMap("customers"). This is the simplest way to get a hold of this Map, but there are other ways, e.g. the map could be set through dependency injection.

The CustomerService.create method, creates a new Customer object and stores it in the customerMap by calling the put method. After the Customer object is stored, it will eventually be disposed by the garbage collector because Hazelcast stores the binary representation of the object (in this case the Serialized version) and not the actual object.

The CustomerService.get method gets the customer with the given id from the map and returns it. If no customer with the given id is found, null is returned. 

If the Main is called,  the following output is shown:
\begin{verbatim}
Customer Homer with id 483df6a1-3b3f-4fce-9ace-a664c0e1f9eb and name Homer created
\end{verbatim}	

\emph{Concurrency} Because the binary representation of the object is stored, and not the object itself, when an object is read from Hazelcast a new object is returned and not the object that initially was stored. So multiple calls to the customerMap.get will return new object instances every time. So unless object are shared explicitly, thread safety is not needed within the object itself; which keeps the object clean. It also is important to realize that because the actual object isn't stored, changes made to that object after it is stored, so not reflect on its persistent state.
 
So make sure that you deal with getting a new instance every time a map.get is called, since in Hazelcast there is no session functionality like e.g. Hibernate. Where the session guarantees that within a session you always get the same instance. 

Important: Design considerations

In some cases it is an worth considering to create different types of versions for domain objects.
\begin{enumerate}
\item objects that go over the line; Data Transfer Object (DTO).
\item objects that are used the domain; the entities.
\item objects that are stored into the Hazelcast.
\end{enumerate}

I had the displeasure to work with a complex system where this distinction was not made, and although in the beginning features could be implemented relatively quickly, after a while it started to become a tangled mess because:
tight coupling between the users of the api and the implementation of the domain objects. This would have been solved by introducing a DTO, where the DTO contains only the fields that need to be exposed, shielding the users of the DTO from internal implementation details.

tight coupling between the domain objects and their persisted state. This makes domain objects very hard to refactor since their structure can't be changed.
So keep in mind when designing objects. Hazelcast gives you complete freedom in how to design your objects, but it means that you need to take that responsibility yourself.
Important: equals() and hashCode()

When you store a key, value in a distributed Map

, Hazelcast serializes the key and value and stores the byte array version of them in local ConcurrentHashMaps. And this ConcurrentHashMap uses the equals and hashCode methods of byte array version of your key. So it does not take into account the actual equals and hashCode implementations of your objects. So it is important that you choose your keys in a proper way. Implementing the equals and hashCode is not enough, it is also important that the object is always serialized into the same byte array. All primitive types, like; String, Long, Integer and etc. are good candidates for keys to use in Hazelcast. An unsorted Set is an example of a very bad candidate because Java Serialization may serialize the same unsorted set in two different byte arrays.

\section{Updating}

In the previous section the added functionality for getting and creating Customers, in the following section we are going focus on updating customers. 

We are going to extend the CustomerService with updating the name of the customer and we'll start with a very basic implementation of this functionality:

\begin{verbatim}
  public void updateName(String customerId, String newName){
    Customer customer = customerMap.get(customerId);
    if(customer == null)throw new IllegalArgumentException();
    customer.setName(newName);
    customerMap.put(customerId, customer);
  }
\end{verbatim}

And the call would look like this:

\begin{verbatim}
public class Main {
  public static void main(String[] args){
    CustomerService customerService = new CustomerService();
    String id = customerService.create("Homer");
    customerService.updateName(id, "Bart");
  }
}
\end{verbatim}

If we would run this code, we would get the something like this:

\begin{verbatim}
Customer Homer with id e94b4668-7687-4c7d-a84e-379a15b8d62c and name Homer created
Updated customer e94b4668-7687-4c7d-a84e-379a15b8d62c to new name Bart
\end{verbatim}

If you take look at the update method, you can see we get the customer from the customerMap, we change the name and then store it in the customerMap using the put method. It is important to realize that this put method is needed. If you have a Hibernate/JPA background, an explicit call to the storing the entity back into the session/dao isn't needed because all changes are tracked in the session. And once the transaction commits, the session is checked for dirty objects and those are written automatically. With Hazelcast there is no session that tracks used objects, so you need to do it manually. 

\subsection{Lost Update}

In the previous example we updated the name of a customer. The first thing we did was to read the customer from Hazelcast, to update the name field and to write to back to Hazelcast. For this particular example we don't need to worry about concurrency control, but in some cases we need to make sure that the reading/update is done atomically. If we don't take care of it, we'll are going to run into the lost update problem.

To explain the lost update problem we are going to work with a very basic counter example that is
going to be incremented concurrently. First let us implement the counter:

\begin{verbatim}
import java.io.Serializable;
import java.util.UUID;

public class Counter implements Serializable {
  private final String id = UUID.randomUUID().toString();
  private long value;
  public Counter(long value) {this.value = value;}
  public String getId() {return id;}
  public void setValue(long newValue) {this.value = newValue;}
  public void inc() {value++;}
  public long getValue() {return value;}
}
\end{verbatim}

And let us add a service where a counter can be created and incremented:

\begin{verbatim}
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.IMap;

public class CounterService {
  private final IMap<String, Counter> counterMap = Hazelcast.getMap("counters");
  public String create(int value) {
    Counter counter = new Counter(value);
    counterMap.put(counter.getId(), counter);
    return counter.getId();
  }
  public long count(String id){
    return counterMap.get(id).getValue();
  }
  public void increment(String counterId) {
    Counter counter = counterMap.get(counterId);
    if (counter == null) throw new IllegalArgumentException();
    counter.inc();
  }
}
\end{verbatim}

And a test harness to do the actual testing:

\begin{verbatim}
public class Main {

  public static final int INCREMENT_COUNT_PER_THREAD = 1000 * 1000;

  public static void main(String[] args) throws InterruptedException {
    CounterService counterService = new CounterService();
    String id = counterService.create(0);

    Thread[] threads = new Thread[2];
    for (int k = 0; k < threads.length; k++)
      threads[k] = new IncrementThread(counterService, id);

    for (Thread thread : threads) thread.start();

    for (Thread thread : threads) thread.join();

    long actualCount = counterService.count(id);
    long expectedCount = INCREMENT_COUNT_PER_THREAD * threads.length;
    System.out.printf("Lost update detected: %s\n" + (actualCount != expectedCount));
    System.out.printf("Expected count: %s\n", expectedCount);
    System.out.printf("Actual count: %s\n", actualCount);
  }

  static class IncrementThread extends Thread {
    private final CounterService counterService;
    private final String counterId;

    IncrementThread(CounterService counterService, String counterId) {
      this.counterService = counterService;
      this.counterId = counterId;
    }

    public void run() {
      for (int k = 0; k < INCREMENT_COUNT_PER_THREAD; k++)
        counterService.increment(counterId);
    }
  }
}
\end{verbatim}

If we run this code, we are going to see something like:

\begin{verbatim}
Lost update detected: true
Expected count: 2000000
Actual count: 1998562
\end{verbatim}

As you can see, the number of updates should have been 2000000, but it was less. The cause of this problem is that sometimes an update gets lost.

We are going to solve the lost update problem in 2 ways :
pessimistic locking
optimistic locking

IMPORTANT: Hazelcast supports transactions (todo: reference to transaction docs). But transactions can't be used to solve the lost update problem at this moment. This is because the transaction doesn't support any optimistic or pessimistic locking policies, so can't automatically lock the object when loaded or automatically check for a version conflict when committing.
Updating with pessimistic lock

The first thing we need to do is to upgrade the type of the type of the counterMap because we need to access additional functionality. Hazelcast.getMap returns a IMap instance (see www.hazelcast.com/javadoc/com/hazelcast/core/IMap.html for more detail). The IMap extends the java.util.concurrent.ConcurrentMap interface and exposes additional functionality. In our case we need the locking functionality. With pessimistic locking the new increment method will look like this:

\begin{verbatim}
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.IMap;

public class CounterService {
    private final IMap<String, Counter> counterMap = Hazelcast.getMap("counters");
    ....
    public void increment(String counterId) {
        counterMap.lock(counterId);
        try {
            Counter counter = counterMap.get(counterId);
            if (counter == null) throw new IllegalArgumentException();
            counter.inc();
            counterMap.put(counterId, counter);
        } finally {
            counterMap.unlock(counterId);
        }
    }
}
\end{verbatim}

And the output would look like:

\begin{verbatim}
Lost update detected: false
Expected count: 2000000
Actual count: 2000000
\end{verbatim}

As you can see, the lost update problem is not happening anymore.

In the increment method, the first thing we do is to lock the map entry for the given id, so that no other thread can update that map entry at the same moment. After the lock is acquired, we have exclusive access to the counter, and don't need to worry about other threads interleaving. 

If there are other operations that change the state of the Customer, these operations need to acquire the lock on the same map entry, else exclusive access on the customer is not guaranteed. Another way to lock the counter is instead of locking the map.entry, is to create a distributed lock (see: distributed lock chapter). 

For the counterMap.lock(counterId) it doesn't matter if we call it with a non existing id. Behind the scene's an map entry is made with a null value and that entry is immediately locked.

If you want to control on how long you block on acquiring the lock, the IMap exposes 2 alternative versions available that give you more control on blocking:
boolean tryLock(): which acquires the lock if available or fails immediately.
boolean tryLock(long timeout, TimeUnit): which acquires the lock if available, or waits till the lock becomes available, or till it a timeout happens.  
Updating with optimistic locking

The opposite approach of a pessimistic lock is to use an optimistic lock. Since the IMap extends the ConcurrentMap, we can make of the replace(Object key, Object oldValue, Object newValue) to use an optimistic lock. 

Unlike the ConcurrentHashMap, we can't rely on the Customer instance to be the same, since Hazelcast doesn't track instances. (TODO: Therefore the equals method needs to be implemented on the Customer). There are 2 ways for doing this
include all fields of an object to be part of the equals. Personally this isn't my favorite because you need to guarantee there are no cycles in your data structures and it can be expensive performance wise.
introduce a version field and implement equals based on id and version.

We are going to use the second approach since

First we are going to introduce a version field in the counter:

\begin{verbatim}
import java.io.Serializable;
import java.util.UUID;

public class Counter implements Serializable {
    private final String id;
    private long version;
    private long value;
    public Counter(long value) {
        this(UUID.randomUUID().toString(), value, 0);
    }
    public Counter(String id, long value, long version) {
        this.id = id;
        this.value = value;
        this.version = version;
    }
    public String getId() {return id;}
    public void inc() {value++;}
    public long getValue() {return value;}
    public void incVersion() {version++;}
    public long getVersion() { return version;}
    public boolean equals(Object thatObject) {
        if (thatObject == this) return true;
        if (!(thatObject instanceof Counter)) return false;
        Counter that = (Counter) thatObject;
        if(!(that.id.equals(this.id)))return false;
        if(that.version!=this.version)return false;
        return true;
    }
    public int hashCode() {
        int hash = id.hashCode();
        hash = 31*hash + hashCode(version);
        return hash;
    }
    static int hashCode(long l){return ((int)(l ^ (l >>> 32)));}
}
\end{verbatim}

The increment that relies on optimistic locking can be implemented like this:

\begin{verbatim}
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.IMap;

import java.util.concurrent.atomic.AtomicLong;

public class CounterService {
    private final IMap<String, Counter> counterMap = Hazelcast.getMap("counters");
    ...
    public void increment(String counterId) {
        for (; ; ) {
            Counter oldCounter = counterMap.get(counterId);
            if (oldCounter == null) throw new IllegalArgumentException();
            Counter newCounter = new Counter(
                counterId, oldCounter.getValue(), oldCounter.getVersion());
            newCounter.inc();
            newCounter.incVersion();
            if (counterMap.replace(counterId, oldCounter, newCounter)) {
                return;
            } 
        }
    }
}
\end{verbatim}

If we execute it the output would look like this:

\begin{verbatim}
Lost update detected: false
Expected count: 2000000
Actual count: 2000000
\end{verbatim}

As you can see, the lost update problem didn't occur.

What happens in the replace method, that the value is only replaced of the old object equals the object that currently is stored. If another thread made an update, the method will return false and need to be retried. That is the reason to place the functionality inside a loop.

One thing that potentially could cause a problem with optimistic locking is that is that the loop could be executed very often and the system starts to suffer from liveness problems (so some threads are starving, but they are using resources like memory and cpu cycles. So be careful when applying optimistic locking.
Update anti pattern

One of the things I have seen in the past many times is the following:

\begin{verbatim}
class CustomerService{
    ...

    public Customer get(String customerId){
        return customerMap.get(customerId);
    }
    public void update(Customer customer){
        customerMap.put(customer.getId(),customer);
    }
}
\end{verbatim}

Where the code is used like this:

\begin{verbatim}
Customer customer = customerService.get("1234");
customer.setName("foobar street 1234");
customerService.update(customer);
\end{verbatim}

In my book this is an anti pattern for the following reasons:
you are exposing the implementation detail of your domain objects to the outside world. For the Customer class is not that interesting, although the field version has not much to do with the domain concept of customer; it is an implementation detail.  If you expose your internal domain object directly to the outside world, it will be hard to change.
because the object object is exposed, everybody can poke inside the internals and then store it. So it is very easy to get the object in an inconsistent state or to prevent all kinds of business logic (e.g. send an email if the name of a customer is changed) to be added.
concurrency reasons; it is very easy to run into a lost update. Of course a version field can be added to solve this problem.

That is why I prefer using 2 different types of objects:
domain objects: these objects are the objects that are used behind the services and will not be exposed to the outside world (unless it is only for read only purposes, e.g. to render a web page)
data transfer objects: these objects only contain the data
Hazelcast doesn't enforce any design direction on you. So if you want to expose a general purpose update method, you are completely free to do so.

\section{Hazelcast Query API}

To explain the Hazelcast Query API we'll begin with a naive example; retrieving all customers with the given name.

\begin{verbatim}
public Set<Customer> getWithName(String name){
    Set<Customer> result = new HashSet<Customer>();
    for(Customer customer: customerMap.values()){
        if(customer.getName().equals(name))
           result.add(customer);
    }
    return result;
}
\end{verbatim}

Although the code is simple it contains a few problems:
\begin{enumerate}
\item Not parallelizable: One node will iterate over all customers; imagine that there are millions of customers. So this approach doesn't make use of the computing capacity of the machines.
\item Inefficient: all customers need to be pulled into memory, so need to be rematerialized. After the rematerialization only a single field is read and then the object is discarded. 
\end{enumerate}

Luckily Hazelcast solves these problems by supporting distributed queries using 2 different mechanisms:
\begin{enumerate}
\item Criteria API
\item Distributed SQL Query
\end{enumerate}

\subsection{Criteria API}

The distributed version looks like this:

\begin{verbatim}
public Set<Customer> getWithName(String name){
    EntryObject e = new PredicateBuilder().getEntryObject();
    Predicate predicate = e.get("name").equals(name);
    return (Set<Customer>) customerMap.values(predicate);
}
\end{verbatim}

Explain EntryObject, Predicate.

\subsection{Distributed SQL Query}
It also is possible instead of using the programmatic api to create a query, to use a more SQL like language:

\begin{verbatim}
public Set<Customer> getWithName(String name){
    Predicate predicate = new SqlPredicate(String.format("name = %s",name));
    return (Set<Customer>) customerMap.values(predicate);
}
\end{verbatim}

supported SQL syntax:
TODO: Is it case sensitive?

\subsubsection{AND/OR}
<expression> AND <expression> AND <expression>...
\begin{enumerate}
\item active AND age>30
\item active=false OR age = 45 OR name = 'Joe'
\item active AND (age >20 OR salary < 60000)
\end{enumerate}

\subsection{=, !=, <, <=, >, >=}
<expression> = value
\begin{enumerate}
\item age <= 30
\item name ="Joe"
\item salary != 50000
\end{enumerate}

\subsubsection{BETWEEN}
<attribute> [NOT] BETWEEN <value1> AND <value2>

\begin{enumerate}
\item age BETWEEN 20 AND 33 (same as age >=20 AND age<=33)
\item age NOT BETWEEN 30 AND 40 (same as age <30 OR age>40)
\end{enumerate}

%\subsection{LIKE}
%<attribute> [NOT] LIKE 'expression'
% (percentage sign) is placeholder for many characters, _ (underscore) is placeholder for only one character.
%\begin{enumerate}
%\item name LIKE 'Jo%' (true for 'Joe', 'Josh', 'Joseph' etc.)
%\item name LIKE 'Jo_' (true for 'Joe'; false for 'Josh')
%\item name NOT LIKE 'Jo_' (true for 'Josh'; false for 'Joe')
%\item name LIKE 'J_s%' (true for 'Josh', 'Joseph'; false 'John', 'Joe')
%\begin{enumerate}

\subsubsection{IN}
<attribute> [NOT] IN (val1, val2, ...)
\begin{enumerate}
\item age IN (20, 30, 40)
\item age NOT IN (60, 70)
\end{enumerate}

\section{Gotcha's}

When Map.entrySet(), Map.keySet() or Map.values() is called, a snapshot of the current state of the map is returned. Changes that are made in the map, so not reflect into changes these maps. Also when changes are made on these collections, an UnsupportedOperationException is thrown.

\section{What is next}
In this chapter a lot of the basic operations on the Distributed Map were explained. In the next chapter we'll cover more advanced features.