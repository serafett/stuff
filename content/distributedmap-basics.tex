\chapter{Distributed Map Basics}

In this chapter, we'll learn how to use one of the most important data structures for distributed applications; the distributed map. A few of the differences between an ordinary map and a distributed map in Hazelcast
\begin{enumerate}
\item scalable; so just add or remove machine when needed to match the required capacity.
\item high availability; so if a machine crashes, a different machine can take over. 
\end{enumerate}
This makes the distributed map the ideal workhorse to write distributed applications.

The HazelcastMap implements the java.collections.Map interface, so replacing an ordinary map implementation by the Hazelcast version, doesn't need to be a complex operation and also programmers will be up to speed quickly.

TODO: ConcurrentMap operations never throw java.util.ConcurrentModificationException. Add somewhere.

TODO: Give some idea about capacity in production.. number of entries... total size.

\begin{enumerate}
\item Reading/Writing
\item Custom Keys
\item Query API
\item Concurrency Control
\item MultiMap
\item ManyMap
\end{enumerate}

\section{Reading/Writing}
Because the HazelcastMap implements the Map interface, putting entries and retrieving them is very simple since you can use operators use normally use when you deal with the map like get/put etc. Here is a small example where you can see 2 members; in the put member an item is placed in the map, and in the get member it is retrieved.

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.util.Map;
public class PutMember {
    public static void main(String[] args) {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        Map<String, String> map = hzInstance.getMap("map");
        map.put("1", "Tokyo");
    }
}

import com.hazelcast.core.*;
import java.util.Map;
public class GetMember {
    public static void main(String[] args) {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        Map<String, String> map = hzInstance.getMap("map");
        System.out.println(map.get("1"));
    }
}
\end{lstlisting}

\section{Custom Keys}
My experience is that in most cases when you work with a Hazelcast map you will make use of a Long, Integer or String as key. But in some cases you will need to create custom keys, but to do it correctly in Hazelcast, you need to understand how this works. 

When you store a key/value in a Hazelcast map, the actual objects are not stored in the map because an object can't move from one JVM to another. Instead the key/value are serialized to byte-arrays and these will be stored in a local ConcurrentHashMap. So the Hazelcast map will not make use of the hashcode/equals of your object, but of the byte array versions of your object. That is why you need to make sure that equal keys result in equal byte arrays. 

Below is an example of a key implementation that is valid if you use it as key in a normal HashMap, but stops working when it is used as a key in a Hazelcast map:
\begin{lstlisting}[language=java]
public final class BrokenKey implements Serializable {
    private final String significant;
    private final String insignificant;
    public BrokenKey(String significant, String insignificant) {
        this.significant = significant;
        this.insignificant = insignificant;
    }
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof BrokenKey)) return false;
        BrokenKey that = (BrokenKey) o;
        return that.significant.equals(this.significant);
    }
    public int hashCode() {
       return significant.hashCode();
   }
}
\end{lstlisting}
Although equals and hashCode are implemented correctly; equal object should result in the same hashCode. In this case equals and hashCode are both based solely on the significant field. So if you have 2 keys:
\begin{verbatim}
BrokenKey key1 = new BrokenKey("a","b");
BrokenKey key2 = new BrokenKey("a","c");
\end{verbatim} 
Then 'key1.equals(key2)' and 'key1.hashCode()==key2.hashCode()' is true. But since the byte-array content of both objects is different, this key implementation should not be used with a Hazelcast map.

TODO:
Note that the distributed Set and List stores its entries as the keys in a distributed Map. So the notes above apply to the objects you store in Set and List.

\section{Hazelcast Query API}

To explain the Hazelcast Query API we'll begin with a naive example; retrieving all customers with the given name.

\begin{verbatim}
public Set<Customer> getWithName(String name){
    Set<Customer> result = new HashSet<Customer>();
    for(Customer customer: customerMap.values()){
        if(customer.getName().equals(name))
           result.add(customer);
    }
    return result;
}
\end{verbatim}

Although the code is simple it contains a few problems:
\begin{enumerate}
\item Not parallelizable: One node will iterate over all customers; imagine that there are millions of customers. So this approach doesn't make use of the computing capacity of the machines.
\item Inefficient: all customers need to be pulled into memory, so need to be deserialized before a single field is read and then the object is discarded. 
\end{enumerate}

Luckily Hazelcast solves these problems by supporting distributed queries using 2 different mechanisms:
\begin{enumerate}
\item Criteria API
\item Distributed SQL Query
\end{enumerate}

\subsection{Criteria API}

The distributed version looks like this:

\begin{verbatim}
public Set<Customer> getWithName(String name){
    EntryObject e = new PredicateBuilder().getEntryObject();
    Predicate predicate = e.get("name").equals(name);
    return (Set<Customer>) customerMap.values(predicate);
}
\end{verbatim}

Explain EntryObject, Predicate.

\subsection{Distributed SQL Query}
It also is possible instead of using the programmatic api to create a query, to use a more SQL like language:

\begin{verbatim}
public Set<Customer> getWithName(String name){
    Predicate predicate = new SqlPredicate(String.format("name = %s",name));
    return (Set<Customer>) customerMap.values(predicate);
}
\end{verbatim}

supported SQL syntax:
TODO: Is it case sensitive?

\subsubsection{AND/OR}
<expression> AND <expression> AND <expression>...
\begin{enumerate}
\item active AND age>30
\item active=false OR age = 45 OR name = 'Joe'
\item active AND (age >20 OR salary < 60000)
\end{enumerate}

\subsection{=, !=, <, <=, >, >=}
<expression> = value
\begin{enumerate}
\item age <= 30
\item name ="Joe"
\item salary != 50000
\end{enumerate}

\subsubsection{BETWEEN}
<attribute> [NOT] BETWEEN <value1> AND <value2>

\begin{enumerate}
\item age BETWEEN 20 AND 33 (same as age >=20 AND age<=33)
\item age NOT BETWEEN 30 AND 40 (same as age <30 OR age>40)
\end{enumerate}

%\subsection{LIKE}
%<attribute> [NOT] LIKE 'expression'
% (percentage sign) is placeholder for many characters, _ (underscore) is placeholder for only one character.
%\begin{enumerate}
%\item name LIKE 'Jo%' (true for 'Joe', 'Josh', 'Joseph' etc.)
%\item name LIKE 'Jo_' (true for 'Joe'; false for 'Josh')
%\item name NOT LIKE 'Jo_' (true for 'Josh'; false for 'Joe')
%\item name LIKE 'J_s%' (true for 'Josh', 'Joseph'; false 'John', 'Joe')
%\begin{enumerate}

\subsubsection{IN}
<attribute> [NOT] IN (val1, val2, ...)
\begin{enumerate}
\item age IN (20, 30, 40)
\item age NOT IN (60, 70)
\end{enumerate}

\section{Concurrency Control}
Hazelcast supports concurrency control, it can either be pessimistic using locks or optimistic using compare and swap operations. Todo: what about transactions?

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.io.Serializable;
public class RacyUpdateMember {
    public static void main(String[] args) throws Exception {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        IMap<String, Value> map = hzInstance.getMap("map");
        String key = "1";
        map.put(key, new Value());
        System.out.println("Starting");
        for (int k = 0; k < 1000; k++) {
            if(k%100 == 0)System.out.println("At: "+k);
            Value value = map.get(key);
            Thread.sleep(10);
            value.field++;
            map.put(key, value);
        }

        System.out.println("Finished! Result = " + map.get(key).field);
    }
    static class Value implements Serializable {
        public int field;
    }
}
\end{lstlisting}[language=java]

\subsection{Pessimistic Locking}
The classic way to solve the race problem is to use a lock. In Hazelcast there are various ways to lock, but for this example we'll use the locking functionality provided by the map using the map.lock/map.unlock methods.

Todo: are these reentrant?
todo: are these fair?
also the regular locking rules apply, don't lock too long, don't lock too much.

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.io.Serializable;
public class PessimisticUpdateMember {
    public static void main(String[] args) throws Exception {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        IMap<String, Value> map = hzInstance.getMap("map");
        String key = "1";
        map.put(key, new Value());
        System.out.println("Starting");
        for (int k = 0; k < 1000; k++) {
            map.lock(key);
            try {
                Value value = map.get(key);
                Thread.sleep(10);
                value.field++;
                map.put(key, value);
            } finally {
                map.unlock(key);
            }
        }
        System.out.println("Finished! Result = " + map.get(key).field);
    }
    static class Value implements Serializable {
        public int field;
    }
}
\end{lstlisting}

Another way to lock is to acquire some predictable Lock object from Hazelcast. You could give every value its own lock, but you could also create a stripe of locks. Although it potentially can increase contention, it will reduce space.

\subsection{Optimistic Locking}
Does optimistic rely on a lock or is truly using cas?
It is important to implement equals in the value, because this is used to determine of 2 objects are equal. With the ConcurrentHashMap it is based on object reference. On the keys the byte-array equals is used, but on the replace(key,oldValue,newValue) the equals is used. If you fail to forget it, your code will not work!

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.io.Serializable;
//This code is broken on purpose.
public class OptimisticMember {
    public static void main(String[] args) throws Exception {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        IMap<String, Value> map = hzInstance.getMap("map");
        String key = "1";
        map.put(key, new Value());
        System.out.println("Starting");
        for (int k = 0; k < 1000; k++) {
            if(k%10==0) System.out.println("At: "+k);
            for (; ; ) {
                Value oldValue = map.get(key);
                Value newValue = new Value(oldValue);
                //   Thread.sleep(10);
                newValue.field++;
                if(map.replace(key, oldValue, newValue))
                    break;
            }
        }
        System.out.println("Finished! Result = " + map.get(key).field);
    }
    static class Value implements Serializable {
        public int field;
        public Value(){}
        public Value(Value that) {
            this.field = that.field;
        }
        public boolean equals(Object o){
            if(o == this)return true;
            if(!(o instanceof Value))return false;
            Value that  = (Value)o;
            return that.field == this.field;
        }
    }
}
\end{lstlisting}

Aba problem; it can be that the following thing happens. And explain how it can be solved by adding a version; although all the other fields will be equal, the version field will prevent objects from being seen as equal.

\subsection{Pessimistic vs Optimistic}

\section{Multi Map}

In some cases you need to attach multiple values for a single key. Luckily Hazelcast provides out of the box functionality for that in the form of a MultiMap. The Hazelcast MultiMap documentation can be found here: http://www.hazelcast.com/javadoc/com/hazelcast/core/MultiMap.html
The MultiMap doesn't implement the java.util.Map interface since the signatures of the method are different. The MultiMap does have support for most of the functionality provided by the IMap (so locking, listeners etc). But it doesn't support indexing.

todo: good example with multi map; perhaps use orderline and drop order?
todo: what is the reason not to use a collection as value?

Creating a MultiMap

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
public class PutMember {
    public static void main(String[] args){
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        MultiMap<String,String> map = hzInstance.getMultiMap("map");
        
        map.put("Peter","England");
        map.put("Peter","Holland");
        map.put("Talip","Turkey");
    }
}
\end{lstlisting}

\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.util.Collection;
public class PrintMember {
    public static void main(String[] args) {
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        MultiMap<String,String> map = hzInstance.getMultiMap("map");
        for(String key: map.keySet()){
            Collection<String> values = map.get(key);
            System.out.printf("%s -> %s\n",key,values);
        }
    }
}
\end{lstlisting}

It is important to realize that this a copy of the values at some moment in time. Changes to this collection will not reflect as changes in the stored values. todo: is this collection readonly?

Removing items;
with the multimap you can remove an item from the value collection. Todo what happens when the collection is null, is it removed or they empty collection stays?

\section{Gotcha's}

When Map.entrySet(), Map.keySet() or Map.values() is called, a snapshot of the current state of the map is returned. Changes that are made in the map, so not reflect into changes these maps. Also when changes are made on these collections, an UnsupportedOperationException is thrown.

\section{What is next}
In this chapter a lot of the basic operations on the Distributed Map were explained. In the next chapter we'll cover more advanced features.







