\chapter{Network configuration}

Hazelcast can run perfectly within a single JVM and this is excellent for development and to speed up testing. But Hazelcast true strength becomes apparent when a cluster of JVM's running on multiple machines is created. Having a cluster of machines makes Hazelcast resilient to failure; if one machine fails, the data will failover to another machine as if nothing happened. It also makes Hazelcast scalable; just add extra machines to the cluster, to gain additional capacity. Creating clusters can be done by configuring the network settings.

To configure the networking settings, we are going to make use of the following minimalistic Hazelcast member.
\begin{lstlisting}[language=java]
import com.hazelcast.core.Hazelcast;
public class Member {
    public static void main(String[] args) {
        Hazelcast.newHazelcastInstance();
    }
}
\end{lstlisting}

In this chapter we are going to rely on the hazelcast.xml config file to set the networking options, but it can also be done programmatically. Within the config file there is a network section that can be configured:
\begin{lstlisting}[language=xml]
<hazelcast>
    ...
    <network>
        ...  
   </network>
    ...
</hazelcast>
\end{lstlisting}

\section{Port}
One of the most basic configuration settings is the port Hazelcast is going to use for communication between the members. This can be done by the 'port' property in the network configuration which defaults to 5701. If the port is already in use and if auto-increment property is true, it is the default, Hazelcast will automatically try to find next port. Example:
\begin{lstlisting}[language=xml]
<hazelcast>
    <network>
        <port auto-increment="true">5701</port>
   </network>
</hazelcast>
\end{lstlisting}
In this example you can see the explicit set values, but you don't need to specify them since they are also the default. If you start the member, you will get output like:
\begin{lstlisting}
...
Jan 19, 2013 10:58:46 AM com.hazelcast.impl.AddressPicker
INFO: Prefer IPv4 stack is true.
Jan 19, 2013 10:58:46 AM com.hazelcast.impl.AddressPicker
INFO: Picked Address[192.168.1.104]:5701, using socket ServerSocket[addr=/0.0.0.0,localport=5701], bind any local is true
Jan 19, 2013 10:58:47 AM com.hazelcast.system
INFO: [192.168.1.104]:5701 [dev] Hazelcast Community Edition 2.5 (20130116) starting at Address[192.168.1.104]:5701
Jan 19, 2013 10:58:47 AM com.hazelcast.system
INFO: [192.168.1.104]:5701 [dev] Copyright (C) 2008-2012 Hazelcast.com
Jan 19, 2013 10:58:47 AM com.hazelcast.impl.LifecycleServiceImpl
INFO: [192.168.1.104]:5701 [dev] Address[192.168.1.104]:5701 is STARTING
Jan 19, 2013 10:58:47 AM com.hazelcast.impl.Node
WARNING: [192.168.1.104]:5701 [dev] No join method is enabled! Starting standalone.
...
\end{lstlisting}
As you can see, the port is 5701. If another member is started, you will get output like this:
\begin{lstlisting}
...
INFO: Prefer IPv4 stack is true.
Jan 19, 2013 11:01:09 AM com.hazelcast.impl.AddressPicker
INFO: Picked Address[192.168.1.104]:5702, using socket ServerSocket[addr=/0.0.0.0,localport=5702], bind any local is true
Jan 19, 2013 11:01:09 AM com.hazelcast.system
INFO: [192.168.1.104]:5702 [dev] Hazelcast Community Edition 2.5 (20130116) starting at Address[192.168.1.104]:5702
Jan 19, 2013 11:01:09 AM com.hazelcast.system
INFO: [192.168.1.104]:5702 [dev] Copyright (C) 2008-2012 Hazelcast.com
Jan 19, 2013 11:01:09 AM com.hazelcast.impl.LifecycleServiceImpl
INFO: [192.168.1.104]:5702 [dev] Address[192.168.1.104]:5702 is STARTING
Jan 19, 2013 11:01:09 AM com.hazelcast.impl.Node
WARNING: [192.168.1.104]:5702 [dev] No join method is enabled! Starting standalone.
Jan 19, 2013 11:01:09 AM com.hazelcast.impl.Node
WARNING: [192.168.1.104]:5702 [dev] Config seed port is 5701 and cluster size is 1. Some of the ports seem occupied!
Jan 19, 2013 11:01:09 AM com.hazelcast.impl.LifecycleServiceImpl
INFO: [192.168.1.104]:5702 [dev] Address[192.168.1.104]:5702 is STARTED...
\end{lstlisting}
As you can see the port of the second member is 5702. If you look carefully, at the end you see a warning about cluster size is 1. This is because the created members are currently not part of a cluster, but are standalone. To create a cluster, see the Member Discovery section.

\section{Join Mechanism }
Hazelcast supports 3 mechanisms for nodes to join the cluster: multicast, tcp/ip-cluster, Amazon EC2. Without these discovery mechanisms, the members's will not form a cluster, but will remain stand alone Hazelcast instances. After joining the cluster, Hazelcast relies on TCP for internal communication.

\subsection{Multicast}
With multicast discovery a member will send a message to all members that listen on the multi-cast port. It is the easiest mechanism to configure, but not always available. 

Underneath you can see a very minimalistic multicast configuration:
\begin{lstlisting}[language=xml]
<hazelcast>
    <network>
        <join><multicast enabled="true"/></join>
    </network>
</hazelcast>
\end{lstlisting}
If you start one member, you will see output like this:
\begin{lstlisting}
Jan 22, 2013 2:06:28 PM com.hazelcast.impl.AddressPicker
INFO: Prefer IPv4 stack is true.
Jan 22, 2013 2:06:28 PM com.hazelcast.impl.AddressPicker
INFO: Picked Address[192.168.1.104]:5701, using socket ServerSocket[addr=/0.0.0.0,localport=5701], bind any local is true
Jan 22, 2013 2:06:28 PM com.hazelcast.system
INFO: [192.168.1.104]:5701 [dev] Hazelcast Community Edition 2.5 (20130116) starting at Address[192.168.1.104]:5701
Jan 22, 2013 2:06:28 PM com.hazelcast.system
INFO: [192.168.1.104]:5701 [dev] Copyright (C) 2008-2012 Hazelcast.com
Jan 22, 2013 2:06:28 PM com.hazelcast.impl.LifecycleServiceImpl
INFO: [192.168.1.104]:5701 [dev] Address[192.168.1.104]:5701 is STARTING
Jan 22, 2013 2:06:30 PM com.hazelcast.impl.MulticastJoiner
INFO: [192.168.1.104]:5701 [dev] 

Members [1] {
	Member [192.168.1.104]:5701 this
}

Jan 22, 2013 2:06:30 PM com.hazelcast.impl.LifecycleServiceImpl
INFO: [192.168.1.104]:5701 [dev] Address[192.168.1.104]:5701 is STARTED
\end{lstlisting}	
As you can see the member is started and currently the cluster only has a single member. If you start another member on the same machine, on the console of the first member the following will be added to the output:
\begin{lstlisting}
Jan 22, 2013 2:07:14 PM com.hazelcast.nio.SocketAcceptor
INFO: [192.168.1.104]:5701 [dev] 5701 is accepting socket connection from /192.168.1.104:54199
Jan 22, 2013 2:07:14 PM com.hazelcast.nio.ConnectionManager
INFO: [192.168.1.104]:5701 [dev] 5701 accepted socket connection from /192.168.1.104:54199
Jan 22, 2013 2:07:19 PM com.hazelcast.cluster.ClusterManager
INFO: [192.168.1.104]:5701 [dev] 

Members [2] {
	Member [192.168.1.104]:5701 this
	Member [192.168.1.104]:5702
}
\end{lstlisting}	
As you can see, the first member can see the second member. And if we look at the end of logging for the second member, we'll find something similar:
\begin{lstlisting}
Members [2] {
	Member [192.168.1.104]:5701
	Member [192.168.1.104]:5702 this
}
\end{lstlisting}		
We now have a 2 member Hazelcast cluster running on a single machine, but it starts to become more interesting if you start multiple members on different machines.

If you don't see members joining, then it is likely because multicast has been disabled. On *NIX environments you can check if your network interface supports multicast by calling 'ifconfig | grep -i multicast', but it doesn't mean that it is available.

The following properties are available:
\begin{enumerate}
\item multicast-group: With multicast a process is part of the multicast group. Only other processes that are part of the same group will receive each others messages. The multicast group ip address doesn't conflict with normal unicast ip addresses since they have a specific range that is excluded from normal unicast usage. 224.0.0.0 to 239.255.255.255 (inclusive) defaults:224.2.2.3. The address 224.0.0.0 is reserved and should not be used.  So by setting the multicast-group or the multicast-port, you can have separate Hazelcast clusters within the same network. We highly recommend using different <multicast-group> IP for your production, development and test clusters for clean separation.
\item 	multicast-port: The port of the multicast socket where the Hazelcast member listens and sends discovery messages on. Unlike normal unicast sockets where only a single process can listen to a port, with multicast sockets multiple processes can listen to the same port. So you don't need to be worried about having multiple Hazelcast members that run on the same JVM are going to conflict. defaults:54327
\item multicast-time-to-live-seconds: Set the default time-to-live for multicast packets sent out on this in order to control the scope of the multicasts. Defaults to 32 and a maximum of 255.
\item multicast-timeout-seconds:defaults:2 [todo]
\item trusted-interfaces:[todo]
\end{enumerate}

\subsection{TCP/IP cluster}
In the previous section we made use of multicast, but this is not always an option because in production environments it often is prohibited and in cloud environments it often is not supported. That is why there is another discovery mechanism: the TCP/IP cluster. The idea is that there should be a one or more well known members to connect to. Once members have connected to these well known members and joined the cluster, they will keep each other up to date with all member addresses.

Underneath is an example of a TCP/IP cluster configuration where such a well known member is configured using an IP:
\begin{lstlisting}[language=xml]
<hazelcast>
    <network>
        <join>
            <multicast enabled="false"/>
            <tcp-ip enabled="true">
                <interface>192.168.1.104</interface> 
            </tcp-ip>
        </join>
    </network>
</hazelcast>
\end{lstlisting}
Multiple members can be configured using a comma or semi colon separated list, or multiple interface entries. A range of IP's can be defined using the following syntax '192.168.1.100-200'. If depending on IP addresses is not desirable, it also is possible to provide the hostname using one or more '<hostname>foo</hostname>' sections. If no port is provided, Hazelcast will automatically try port 5701..5703. 

When there is a large number of IP's listed and members can't build up a cluster, the 'conn-timeout-seconds' attribute, which defaults to 5, can be set to a higher value. The first scan and delay between scans can be configured using property 'hazelcast.merge.first.run.delay.seconds' and respectively 'hazelcast.merge.next.run.delay.seconds'. By default Hazelcast will scan every 5 seconds.
[todo]
hazelcast.socket.bind.any =false
This will make sure that at least the TCP/IP communication is binding to the specified network address.

\subsection{EC2 Auto Discovery}

Hazelcast supports EC2 Auto Discovery as of 1.9.4. It is useful when you don't want or can't provide the list of possible IP addresses. Here is a sample configuration: Disable join over multicast and tcp/ip and enable aws. Also provide the credentials. The aws tag accepts an attribute called "conn-timeout-seconds". The default value is 5. Increasing this value is recommended if you have many IP's listed and members can not properly build up the cluster.

\begin{lstlisting}[language=xml]
<hazelcast>
    <network>
       <join>
           <multicast enabled="false"/>
           <aws enabled="true">
               <access-key>my-access-key</access-key>
               <secret-key>my-secret-key</secret-key>
               <region>us-west-1</region>                              <!-- optional, default is us-east-1 -->
               <security-group-name>hazelcast-sg</security-group-name> <!-- optional -->
               <tag-key>type</tag-key>                                  <!-- optional -->
               <tag-value>hz-nodes</tag-value>                          <!-- optional -->
            </aws>
       </join>
    </network>
</hazelcast>
\end{lstlisting}

\section{Specifying network interfaces}
Most server machines can have multiple network interfaces. 

You can also specify which network interfaces that Hazelcast should use. Servers mostly have more than one network interface so you may want to list the valid IPs. Range characters ('*' and '-') can be used for simplicity. So 10.3.10.*, for instance, refers to IPs between 10.3.10.0 and 10.3.10.255. Interface 10.3.10.4-18 refers to IPs between 10.3.10.4 and 10.3.10.18 (4 and 18 included). If network interface configuration is enabled (disabled by default) and if Hazelcast cannot find an matching interface, then it will print a message on console and won't start on that member.

\begin{lstlisting}[language=xml]
<hazelcast>
    <network>
        <interfaces enabled="true">
            <interface>10.3.16.*</interface> 
            <interface>10.3.10.4-18</interface> 
            <interface>192.168.1.3</interface>         
        </interfaces>    
    </network>
</hazelcast>
\end{lstlisting}

[todo: when there are multiple interfaces, which is selected by default?]
[todo: does this work for multicast?]
[todo: every machine could have different interfaces. So should all the interfaces be listed of all machines? Or should an hazelcast config per machine be 'generated'?]

\section{Partition Group Configuration}
Hazelcast distributes key objects into partitions (blocks) using a consistent hashing algorithm and those partitions are assigned to members. That means an entry is stored in a member which is owner of partition to that entry's key is assigned. Number of total partitions is default 271 and can be changed with configuration property 'hazelcast.map.partition.count'. Along with those partitions, there are also copies of them as backups. Backup partitions can have multiple copies due to backup count defined in configuration, such as first backup partition, second backup partition etc. As a rule, a member can not hold more than one copy of a partition (ownership or backup). By default Hazelcast distributes partitions and their backup copies randomly and equally among cluster members assuming all members in the cluster are identical.

What if some members share same JVM or physical machine or chassis and you want backups of these members to be assigned to members in another machine or chassis? What if processing or memory capacities of some members are different and you do not want equal number of partitions to be assigned to all members?

You can group members in same JVM (or physical machine) or members located in the same chassis. Or you can group members to create identical capacity. We call these groups as partition groups. This way partitions are assigned to those partition groups instead of single members. And backups of these partitions are located in another partition group.

When you enable partition grouping, Hazelcast presents two choices to configure partition groups at the moments.

First one is to group members automatically using IP addresses of members, so members sharing same network interface will be grouped together.

\begin{lstlisting}
<partition-group enabled="true" group-type="HOST_AWARE" />
Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled(true).setGroupType(MemberGroupType.HOST_AWARE);
\end{lstlisting}

Second one is custom grouping using Hazelcast's interface matching configuration. This way, you can add different and multiple interfaces to a group. You can also use wildcards in interface addresses.

\begin{lstlisting}
<partition-group enabled="true" group-type="CUSTOM">
    <member-group>
        <interface>10.10.0.*</interface>
        <interface>10.10.3.*</interface>
        <interface>10.10.5.*</interface>
    </member-group>
    <member-group>
        <interface>10.10.10.10-100</interface>
        <interface>10.10.1.*</interface>
        <interface>10.10.2.*</interface>
    </member-group
</partition-group>
\end{lstlisting}

\section{SSL}
In a production environment often you want to prevent that the communication between Hazelcast members can be tampered or can be read, with because it could contains sensitive information. Luckily Hazelcast provides a solution for that by enabling SSL encryption.

The basic functionality is provided by 'com.hazelcast.nio.ssl.SSLContextFactory' interface and configurable through the the SSL section in network configuration. Luckily Hazelcast provides a default implementation called the 'com.hazelcast.nio.ssl.BasicSSLContextFactory' which we are going to use for the example:
\begin{lstlisting}[language=xml]
<hazelcast>
    <network>
        <join><multicast enabled="true"/></join>
        <ssl enabled="true">
            <factory-class-name>com.hazelcast.nio.ssl.BasicSSLContextFactory</factory-class-name>
            <properties>
                <property name="keyStore">keyStore.jks</property>
                <property name="keyStorePassword">password</property>
            </properties>
        </ssl>
    </network>
</hazelcast>
\end{lstlisting}
The 'keyStore' is the path to the keyStore. [todo: is it possible to provide a classpath reference so it can be included in the jar, and is this a desirable practice?] and the 'keyStorePassword' is the password of the keystore. In the example code you can find an already created keystore and also the documentation to create one yourself.

When you start a member, you will see that SSL is enabled:
\begin{lstlisting}
Jan 19, 2013 4:00:43 PM com.hazelcast.nio.ConnectionManager
INFO: [192.168.1.104]:5701 [dev] SSL is enabled
\end{lstlisting}

There are some additional properties that can be set on the BasicSSLContextFactory:
\begin{enumerate}
\item keyManagerAlgorithm: defaults to 'SunX509'.
\item trustManagerAlgorithm: defaults to 'SunX509'.
\item protocol: defaults to 'TLS'
\end{enumerate}
Another way to configure the keyStore/keyStorePassword is through the 'javax.net.ssl.keyStore' and 'javax.net.ssl.keyStorePassword' system properties.

The recommended practice is to make a single keyStore file that is shared between all instances. It isn't possible to include the keystore within the jar.

\section{Encryption}
Apart from supporting SSL, Hazelcast also supports symmetric encryption based on the Java Cryptography Architecture (JCA). The main advantage of using the latter is that it is easier to set up because you don't need to deal with the keystore. The main disadvantage is that its less secure, because SSL relies on an on the fly created public/private key pair and the symmetric encryption relies on a constant password/salt.

SSL and symmetric encryption solutions will roughly have the same CPU and network bandwidth overhead since for the main data  they rely on symmetric encryption (only the public key is encrypted using asymmetric encryption). Compared to non encrypted data, the performance degradation will be roughly 50%. [todo: increased latency]

Hazelcast used to have support for asymmetric encryption, but due its complex setup, this feature has been removed since Hazelcast 3.0. 

There is currently no support for encryption between a native client and a cluster member. [todo: is there a solution?]

\begin{lstlisting}[language=xml]
<hazelcast>
    <network>
        <join>
            <multicast enabled="true"/>
        </join>
        <symmetric-encryption enabled="true">
            <algorithm>PBEWithMD5AndDES</algorithm>
            <salt>somesalt</salt>
            <password>somepass</password>
            <iteration-count>19</iteration-count>
        </symmetric-encryption>
    </network>
</hazelcast>
\end{lstlisting}
When we start 2 members using the configuration, we'll see that the symmetric encryption is activated:
\begin{lstlisting}
Jan 20, 2013 9:22:08 AM com.hazelcast.nio.SocketPacketWriter
INFO: [192.168.1.104]:5702 [dev] Writer started with SymmetricEncryption
Jan 20, 2013 9:22:08 AM com.hazelcast.nio.SocketPacketReader
INFO: [192.168.1.104]:5702 [dev] Reader started with SymmetricEncryption
\end{lstlisting}
Since encryption relies on the JCA, additional algorithms can be used by enabling the Bouncy Castle JCA provider through property 'hazelcast.security.bouncy.enabled'.

\section{Network Partitioning (Split-Brain Syndrome)}

\section{Firewall}
When a Hazelcast member connects to another Hazelcast member, it binds to server port 5701 (see the port configuration section) to receive the inbound traffic. On the client side also a port needs to be opened for the outbound traffic. By default this will be an 'ephemeral' port since we it doesn't matter which port is being used as long as it is free. The problem is that the lack of control on the outbound port, can be a security issues, because the firewall needs to expose all ports for outbound traffic. 

Luckily Hazelcast is able to control the outbound ports. For example if we want to allow the port range 30000-31000, it can be configured like this:
\begin{lstlisting}[language=xml]
<hazelcast>
    <network>
        <join><multicast enabled="true"/></join>
        <outbound-ports>
            <ports>30000-31000</ports>
        </outbound-ports>
    </network>
</hazelcast
\end{lstlisting}
To demonstrate the outbound ports configuration, start 2 Hazelcast members with this configuration and when the members are fully started, execute 'sudo lsof -i | grep java'. Below you can see the cleaned output of the command:
\begin{lstlisting}
java 46117 IPv4 TCP *:5701 (LISTEN)
java 46117 IPv4 TCP 172.16.78.1:5701->172.16.78.1:30609 (ESTABLISHED)
java 46120 IPv4 TCP *:5702 (LISTEN)
java 46120 IPv4 TCP 172.16.78.1:30609->172.16.78.1:5701 (ESTABLISHED)
\end{lstlisting}
As you can see there are 2 java processes: 46117 and 46120 that listen on port 5701 and 5702 (inbound traffic). You can also see that java process 46120 is using port 30609 for outbound traffic.

Apart from specifying port ranges, you can also specify individual ports. Multiple port configurations can be combined either by separating them by comma or by providing multiple '<ports>' sections. So if you want to use port 30000,30005 and portrange 31000 till 32000, you could say the following '<ports>30000,30005,31000-32000</ports>'. 

\subsection{iptables}
If you are making use of iptables, the following rule can be added to allow for outbound traffic from ports 33000-31000:
\begin{lstlisting}
iptables -A OUTPUT -p TCP --dport 33000:31000 -m state --state NEW -j ACCEPT
\end{lstlisting}
and to control incoming traffic from any address to port 5701:
\begin{lstlisting}
iptables -A INPUT -p tcp -d 0/0 -s 0/0 --dport 5701 -j ACCEPT
\end{lstlisting}

\section{Creating Separate Clusters}
Sometimes it desirable to have multiple clusters on the same network instead of a single cluster. For example when a network is used for different environments or different applications. Luckily this can be done using groups:
\begin{lstlisting}[language=xml]
<hazelcast>
    <group>
        <name>application1</name>
        <password>somepassword</password>
    </group>
</hazelcast>
\end{lstlisting}
The password is optional and defaults to 'drowssap'.

\section{What is next}
The network configuration for Hazelcast is very extensive. There are some features like IPv6, Socket Interceptors, WAN Replication, that have been left out, but can be found on the Hazelcast manual. Also the mailing-list is a very valuable source of information. 

[todo: comment about generating the hazelcast.xml to deal with limitations in the join mechanism. You could generate
a hazelcast.xml based on database content containing the members.]
