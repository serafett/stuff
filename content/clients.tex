\chapter{Hazelcast Clients}

Till so far our examples showed members that were full participants in the cluster; so they will known about others and they will take their share in the load. But in some cases you only want to connect to the cluster to read/write data or execute operations, but you don't want to be a member of the cluster; in other words you want to have a client.

Hazelcast provides 2 client solutions:
\begin{enumerate}
\item native client
\item lite member
\end{enumerate}
These clients are safe to be shared between threads, so you don't need to pool them.

We are going to write a native and lite member client implementation in the following 2 sections. Both are going to put a message on a queue and it will be taken by the following full member:
\begin{lstlisting}[language=java]
import com.hazelcast.config.Config;
import com.hazelcast.core.*;
import java.util.concurrent.BlockingQueue;
public class FullMember {
    public static void main(String[] args)throws Exception{
        Config config = new Config();
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config);
        BlockingQueue<String> queue = hazelcastInstance.getQueue("queue");
        System.out.println(queue.take());       
    }
}
\end{lstlisting}
\section{Native client}
With the native client one can connect to the cluster purely as a client and not have any of the responsibilities a normal cluster member has. When an Hazelcast operation is performed by a client, it is forwarded to a cluster member where it will be processed. A native client needs to have the hazelcast-client.jar on the classpath, the normal Hazelcast jar is not needed. Underneath you can see the native client example:
\begin{lstlisting}[language=java]
import com.hazelcast.client.*;
import com.hazelcast.core.HazelcastInstance;
import java.util.concurrent.BlockingQueue;
public class NativeClient {
    public static void main(String[] args) throws Exception {
        ClientConfig clientConfig = new ClientConfig();
        clientConfig.addAddress("127.0.0.1");
        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
        BlockingQueue<String> queue = client.getQueue("queue");
        queue.put("Hello");
        System.out.println("Message send by lite member!");
    }
}
\end{lstlisting}
The client HazelcastInstance is created based on the com.hazelcast.client.ClientConfig. This config is configured with 127.0.0.1 as address since the full member will be running on the same machine as the client.

First start the full member and then start the native client, and we can see that "Hello!" is printed by the full member. We'll also see that the native client never appears as member in the member listing.	
 
\emph{Failover} is automatically provided by the native client by configuring multiple member addresses, if one member fails, the native client will automatically switch to another member.

There can be hundreds, even thousands of clients connected to the cluster. But by default there are 40 threads, configurable using the hazelcast.executor.client.thread.count property, on each member that will handle all the requests. 

In the native client example, we did a minimal configuration of the ClientConfig and relied on defaults, but there is a lot that can be configured:
\begin{enumerate}
\item addresses: the known addresses of the cluster. They don't need to include all addresses, only enough to make sure that some will always be online.
\item connection timeout: the amount of time in milliseconds the native client waits for one of the members, configured with the addresses property, of the cluster to come online before giving up.
\item credentials: can be used to configure username/password to connect to the cluster. See UsernamePasswordCredentials.
\item group config: configures the group name and the password to access the group.
\item initial connection attempt limit:TODO
\item reconnect attempt limit:TODO
\item reconnect timeout:TODO
\item shuffle:TODO
\item update automatic:TODO
\end{enumerate}

\section{Lite Member}
Although the native client is a very simple mechanism to access the cluster, it has some drawbacks. The most important one is performance, since it knows nothing about the cluster and always needs to go through one of the configured members. That is why another client solution is available: the lite member. In the example underneath you can see see how the lite member works:
\begin{lstlisting}[language=java]
import com.hazelcast.config.Config;
import com.hazelcast.core.*;
import java.util.concurrent.BlockingQueue;
public class LiteMember {
    public static void main(String[] args) throws Exception {
        Config config = new Config().setLiteMember(true);
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config);
        BlockingQueue<String> queue = hazelcastInstance.getQueue("queue");
        queue.put("echo");
        System.out.println("Message send from lite member!");
    }
}
\end{lstlisting}
As you can see there is not a big difference compared to creating a full member. There only difference is the call 'setLiteMember(true)'. 

Lets first start the full member and then start the lite member. In the logging we can see that the members have found each other and in case of the lite member, we'll see something like this:
\begin{verbatim}
Members [2] {
    Member [10.37.129.2]:5701
    Member [10.37.129.2]:5702 this lite
}	
\end{verbatim}	
As you can see the cluster contains 2 members and the 'this' member shows that it is the lite member. If you look in the console of the full member, it will show something similar and it shows that the message send by the lite member has been received.

\emph{same configuration:} A lite member, just like all other member in a cluster, needs to have the same configuration, with the only difference that the lite member field is set. 

\emph{executors:} the lite member will execute tasks from the Hazelcast distributed executor. This is explained in TODO: reference to last chapter of the executors.

\section{Lite member vs Native client}
The lite member is a member of the cluster, it has a socket connection to all other members and knows where data is so it will be able to access it faster. On the downside there will be a lot more clustering overhead and "be on the same data center even on the same RAC". Native Clients can be anywhere in the LAN or WAN. It scales much better and overhead is quite less. So if your clients are less than Hazelcast nodes then LiteMember can be an option; otherwise definitely try Native Client. As a rule of thumb: Try Native client first, if it doesn't perform well enough for you, then consider LiteMember.

[todo: remark about sharing client instance or creating new clients ]

\section{What is next}
In this short chapter we explained the different ways to connect to a Hazelcast cluster using a client.