\chapter{Distributed Executor Service}

Java 5 was perhaps the most fundamental upgrade since Java was released. On a language level we got generics, static imports, enumerations, enhanced for loop and annotations. From a correctness point of view we get the new Java Memory Model. And we also got the executor framework in the java.util.concurrent library.

With the executor you can create task object which need to be implementations of one of the following
2 interfaces:
\begin{enumerate}
\item java.util.Runnable: if your tasks doesn't need to return a value.
\item java.util.concurrent.Callable: if your task does need to return a value.
\end{enumerate}
These tasks are created by one thread, and this thread puts these tasks in the executor where they are
stored in a queue to be picked up by other threads; the worker threads. So while these worker threads are processing the tasks, the task that orignally submitted the tasks is free to do other work. So tasks are being executed asynchronously, although if you use a future you can sync on task completion. Often these worker threaded are pooled threads since threads can be quite expensive to create. 

A very short example:
\begin{lstlisting}[language=java]
class EchoTest{
   private final Executor = Executors.newSingleThreadExecutor();

   public void echoAsynchronously(){
      executor.execute(new Runnable(){
         public void run(){
            ....
         }
      });	
   }
}
\end{lstlisting}

There is virtually no limit in what you can place in such a task; you could execute complex database operations, intensive cpu or IO operations. The problem in a distributed system however, is that the default implementations of the Executor are designed to be run within a single machine. So the thread responsible for creating a tasks will be running in the same JVM as the thread that executed the task.

Hazelcast extends the functionality provided by the Executor framework to make it fit to run in a distributed environment. This means that tasks placed by one JVM can executed on a different JVM. This makes it very easy to scale; just add more machines and the total capacity of processing tasks will increase.

Let start with a very simple example of a distributed executor in Hazelcast. We begin with creating a basic task that will do some waiting and echo a message:

\begin{lstlisting}[language=java]
import java.io.Serializable;
public class EchoTask implements Runnable, Serializable {
    private final String msg;
    public EchoTask(String msg) {
        this.msg = msg;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("echo:" + msg);
    }
}
\end{lstlisting}

This EchoTask implements the Runnable interface so that it can be submitted to the Executor. But it also implements the Serializable interface because it is potentially going to be serialized to a different JVM. 

The next structure we are going to create is the EchoTaskMain:
\begin{lstlisting}[language=java]
import com.hazelcast.core.Hazelcast;
import java.util.concurrent.Executor;
public class EchoTaskMain {
    public static void main(String[] args) throws Exception {
        Executor executor = Hazelcast.getExecutorService("executor");
        for (int k = 0; k < 1000; k++) {
            Thread.sleep(1000);
            executor.execute(new EchoTask("" + k));
        }
        System.out.println("EchoTaskMain finished!");
    }
}
\end{lstlisting}
As you can see we can retrieve the executor using Hazelcast.getExecutor and then we slowly submit 1000 echo tasks. When we execute this EchoTaskMain, we are going to see something like this in the output:

By default Hazelcast configures the executor to have 40 threads in the pool. For this example we only want a single thread per executor, so we configure it like this:

\begin{lstlisting}[language=xml]
<hazelcast>
    <executor-service name="executor">
        <corePoolSize>1</corePoolSize>
        <maxPoolSize>1</maxPoolSize>
    </executor-service>
</hazelcast>
\end{lstlisting}

When we run running the EchoTaskMain you will get output like this:
\begin{verbatim}
Producing echo task: 1
Producing echo task: 2
Producing echo task: 3
Producing echo task: 4
Producing echo task: 5
echo:1
Producing echo task: 6
Producing echo task: 7
Producing echo task: 8
Producing echo task: 9
Producing echo task: 10
echo:2
Producing echo task: 11
Producing echo task: 12	
\end{verbatim}
As you can see the production of messages is 1/second and the consumption is 0.2 per second (each echo task sleeps 5 seconds). There are few ways to speed things up (apart from making the echo task faster):
\begin{enumerate}
\item scale up 
\item scale out .
\end{enumerate}
Both of the strategies to scale are explained below and in practice they are often combined. 

\subsection{Scaling up}
(also called vertical scaling): to increase the capacity of the system we could launch more threads by setting the corePoolSize/maxPoolSize, since each thread can do 0.2 messages/second, if you run 5 threads in parallel, you can process 0.2 messages/second * 5 = 1.0 messages/second. When you scale up you need to look carefully at the machine if it can handle the additional load. If not; you need to increase its resources (either cpu, disk, memory etc); if you fail to do so, the performance could go down instead of up. But scaling up quickly becomes very expensive and scaling out stops to be cost efficient. 

Scaling up the ExecutorService in Hazelcast is very simple, just increment the max-pool-size and core-pool-size. Since we know that having 5 threads is going to give maximum performance, lets set it to five.
\begin{lstlisting}[language=xml]
<hazelcast xsi:schemaLocation="http://www.hazelcast.com/schema/config
            hazelcast-config-2.0.xsd"
           xmlns="http://www.hazelcast.com/schema/config"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <network>
        <join>
            <multicast enabled="true"/>
        </join>
    </network>

    <executor-service name="executor">
        <max-pool-size>5</max-pool-size>
        <core-pool-size>5</core-pool-size>
    </executor-service>
</hazelcast>
\end{lstlisting}

When we run the EchoTaskMain:
\begin{verbatim}
Producing echo task: 2
Producing echo task: 3
Producing echo task: 4
Producing echo task: 5
echo:1
Producing echo task: 6
echo:2
Producing echo task: 7
echo:3
Producing echo task: 8
echo:4
Producing echo task: 9
echo:5
Producing echo task: 10
echo:6
Producing echo task: 11	
\end{verbatim}
As you can see, the tasks are being processed as quickly as they are being produced. So we now have scale the system to its maximum capacity.

\subsection{Scaling out}
(also called horizontal scaling): we can increase the capacity of the system we just launch more boxes. In our case we are going to scale up be launching multiple jvm's since processing the echo tasks doesn't consume any resources because it does a simple wait. But in production system you probably want to add more machines to a cluster

To scale out we just need to launch one of these:

\begin{lstlisting}[language=java]
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
public class EchoTaskWorker {
    public static void main(String[] args) {
        HazelcastInstance hazelcastInstance = Hazelcast.getDefaultInstance();
    }
}
\end{lstlisting}
We don't need to do anything else. This EchoTaskWorker loads the hazelcast.xml, and since the executor is declared there, it will automatically start the executor and the thread in the thread pool. 


When you spawn one of these EchoTaskWorkers, you will see that it start picking up work:
\begin{verbatim}
echo:31
echo:33
echo:35	
\end{verbatim}
So in only a few lines of code, we are now able to scale out! If you want you can spawn more EchoTaskWorkers, but with 1 messages/second being processed and 0.2 messages/second being consumed per node (including the EchoTaskProducer), having more than 5 nodes will not speed things up.

\subsection{Callable}

\subsection{Future}

TODO: Explain lite members also running tasks.

TODO: The executor will be configured with 40 threads core poolsize and 40 threads max pool size.

TODO: Config options

TODO: Finding back context.s

TODO: Explain about workqueue and overflowing. Can it be configured with a blocking queue?
And is there 

TODO: Executor and exceptions. Just verified; with default settings, you don't see any logging.

TODO: 

\begin{lstlisting}[language=java]
import java.util.concurrent.Callable;
import java.io.Serializable;

public class Echo implements Callable<String>, Serializable {
    String input = null;
    public Echo() {
    }
    public Echo(String input) {
        this.input = input;
    }
    public String call() {
        return Hazelcast.getCluster()
          .getLocalMember().toString() + ":" + input;
    }
}
\end{lstlisting}


TODO: The task is also run on client nodes, this is not always what you want. So if this is an issue, inject a custom LoadBalancer in the Executor that prevent sending to lite members.

Echo callable above, for instance, in its call() method, is returning the local member and the input passed in. Remember that Hazelcast.getCluster().getLocalMember() returns the local member and toString() returns the member's address (ip + port) in String form, just to see which member actually executed the code for our example. Of course, call() method can do and return anything you like. Executing a task by using executor framework is very straight forward. Simply obtain a ExecutorService instance, generally via Executors and submit the task which returns aFuture. After executing task, you don't have to wait for execution to complete, you can process other things and when ready use the future object to retrieve the result as show in code below.

\begin{verbatim}
ExecutorService executorService = Executors.newSingleThreadExecutor();
Future<String> future = executorService.submit (new Echo("myinput"));
//while it is executing, do some useful stuff
//when ready, get the result of your execution
String result = future.get();
\end{verbatim}

\section{Distributed Execution}

Distributed executor service is a distributed implementation of java.util.concurrent.ExecutorService. It allows you to execute your code in cluster. In this chapter, all the code samples are based on the Echo class above. Please note that Echo class is Serializable . You can ask Hazelcast to execute your code (Runnable, Callable):

on a specific cluster member you choose.

on the member owning the key you choose.

on the member Hazelcast will pick.

on all or subset of the cluster members.

\begin{verbatim}
import com.hazelcast.core.Member;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.MultiTask;
import com.hazelcast.core.DistributedTask;
import java.util.concurrent.ExecutorService;   
import java.util.concurrent.FutureTask;   
import java.util.concurrent.Future;   
import java.util.Set;

public void echoOnTheMember(String i, Member m) throws Exception {
   FutureTask<String> task = new DistributedTask<String>(new Echo(i), m);
   ExecutorService executorService = Hazelcast.getExecutorService();
   executorService.execute(task);
   String echoResult = task.get();
}
public void echoOnTheMemberOwningTheKey(String i, Object key) throws Exception {
   FutureTask<String> task = new DistributedTask<String>(new Echo(i), key);
   ExecutorService executorService = Hazelcast.getExecutorService();
   executorService.execute(task);
   String echoResult = task.get();
}
public void echoOnSomewhere(String i) throws Exception { 
   ExecutorService executorService = Hazelcast.getExecutorService();
   Future<String> task = executorService.submit(new Echo(i));
   String echoResult = task.get();
}

public void echoOnMembers(String i, Set<Member> m) throws Exception {
   MultiTask<String> task = new MultiTask<String>(new Echo(i), m);
   ExecutorService executorService = Hazelcast.getExecutorService();
   executorService.execute(task);
   Collection<String> results = task.get();
} 
\end{verbatim}

Note that you can obtain the set of cluster members via Hazelcast.getCluster().getMembers() call. You can also extend the MultiTask class to override set(V result), setException(Throwable exception), done() methods for custom behaviour. Just like java.util.concurrent.FutureTask.get() , MultiTask.get() will throw java.util.concurrent.ExecutionException if any of the executions throws exception.

\section{Execution Cancellation}

What if the code you execute in cluster takes longer than acceptable. If you cannot stop/cancel that task it will keep eating your resources. Standard Java executor framework solves this problem with by introducing cancel() api and 'encouraging' us to code and design for cancellations, which is highly ignored part of software development.

\begin{verbatim}
public class Fibonacci<Long> implements Callable<Long>, Serializable {
    int input = 0; 
    public Fibonacci() { 
    } 
    public Fibonacci(int input) { 
        this.input = input;
    } 
    public Long call() {
        return calculate (input);
    }
    private long calculate (int n) {
        if (Thread.currentThread().isInterrupted()) return 0;
        if (n <= 1) return n;
        else return calculate(n-1) + calculate(n-2);
    }
}
\end{verbatim}

The callable class above calculates the fibonacci number for a given number. In the calculate method, we are checking to see if the current thread is interrupted so that code can be responsive to cancellations once the execution started. Following fib() method submits the Fibonacci calculation task for number 'n' and waits maximum 3 seconds for result. If the execution doesn't complete in 3 seconds, future.get() will throw TimeoutException and upon catching it we interruptibly cancel the execution for saving some CPU cycles.

\begin{verbatim}
long fib(int n) throws Exception {
    ExecutorService es = Hazelcast.getExecutorService();
    Future future = es.submit(new Fibonacci(n));  
    try {
        return future.get(3, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        future.cancel(true);            
    }
    return -1;
}
\end{verbatim}
	
fib(20) will probably will take less than 3 seconds but fib(50) will take way longer. (This is not the example for writing better fibonacci calculation code but for showing how to cancel a running execution that takes too long.) future.cancel(false) can only cancel execution before it is running (executing) but future.cancel(true) can interrupt running executions if your code is able to handle the interruption. So if you are willing to be able to cancel already running task then your task has to be designed to handle interruption. If calculate (int n) method didn't have if (Thread.currentThread().isInterrupted()) line, then you wouldn't be able to cancel the execution after it started.

\section{Execution Callback}

ExecutionCallback allows you to asynchronously get notified when the execution is done. When implementing ExecutionCallback.done(Future) method, you can check if the task is already cancelled.

\begin{verbatim}
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.ExecutionCallback;
import com.hazelcast.core.DistributedTask;
import java.util.concurrent.ExecutorService;    
import java.util.concurrent.Future; 
        
ExecutorService es = Hazelcast.getExecutorService();
DistributedTask<String> task = new DistributedTask<String>(new Fibonacci<Long>(10));
task.setExecutionCallback(new ExecutionCallback<Long> () {
    public void done (Future<Long> future) { 
        try {
            if (! future.isCancelled()) {
                System.out.println("Fibonacci calculation result = " + future.get());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
});
es.execute(task);
\end{verbatim}

You could have achieved the same results by extending DistributedTask and overriding the DistributedTask.done() method.

\begin{verbatim}
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.DistributedTask;
import java.util.concurrent.ExecutorService;    
import java.util.concurrent.Future; 
        
ExecutorService es = Hazelcast.getExecutorService();
es.execute(new DistributedTask<String>(new Fibonacci<Long>(10)) {
    public void done () { 
        try {
            if (! isCancelled()) {
                System.out.println("Fibonacci calculation result = " + get());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}); 
\end{verbatim}

\section{What is next}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi libero sem,
interdum eget varius vel, faucibus placerat purus. Sed vulputate diam sit amet
risus dapibus dignissim. Praesent lobortis eleifend augue. Cum sociis natoque
penatibus et magnis dis parturient montes, nascetur ridiculus mus. Morbi libero
turpis, viverra ac vulputate a, faucibus vel quam. Quisque interdum congue
lacus, in tempus nisl tincidunt at. Curabitur sed eros eu enim vehicula
fermentum quis nec justo. Vestibulum rutrum laoreet est, eget condimentum justo
feugiat at. Cras ac sem ac magna ornare tempor non nec nisl. Maecenas feugiat
fringilla nisl, vitae ullamcorper ante posuere a. Sed mollis lacinia interdum.
Vivamus vel urna metus. Nulla eget tellus sem. Praesent volutpat suscipit nulla,
nec dictum arcu iaculis id. Duis pharetra vestibulum sapien, quis pulvinar odio
pharetra id. Cras at erat velit, vel tincidunt elit. Curabitur vehicula leo eu
odio vulputate ac consequat nulla ultricies. Maecenas venenatis condimentum
urna ut ultrices. Aliquam blandit fermentum eros, ac lacinia sem scelerisque
at. Nullam vitae nisi at erat posuere cursus a non velit.
