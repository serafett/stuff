\chapter*{Preface}
Writing concurrent system has been a long passion of mine and it is a very logical step to go from concurrency control within a single JVM to concurrency control over multiple JVM's. There is a big overlap in functionality; a lot of the knowledge that is applicable to concurrency control in a single JVM also applies to concurrency over multiple JVM's; but there also is a whole new dimension of problems that make distributed systems even more interesting to deal with. 
\subsection*{What is Hazelcast}
When you write applications for the JVM for your profession, it is likely that you are going to write server-side applications. Although Java has support for writing desktop applications, the server-side is really where Java shines.

Today, especially with the introduction of cloud computing, it becomes more and more important that server-side systems are:
\begin{enumerate}
\item Scalable: just add and remove machines to match required capacity 
\item Highly available: if one or more machines in a system fail, the system should continue as if nothing happened.
\item Performant: [yusuf: High performing or Efficient:] the performance per machine should be good enough to make it cost efficient.
\end{enumerate}

Hazelcast is an Open Source clustering and highly scalable data distribution platform for the JVM. It is:
\begin{enumerate}
\item Dynamically scalable: this is done by making certain Hazelcast data-structures partitioned like the Hazelcast Map so that partitions can be evenly be spread among the members.  [yusuf: This is done by making certain Hazelcast data-structures - like Hazelcast Map - partitioned so that partitions can be spread evenly among the members.] When members join or leave the cluster, Hazelcast will automatically repartition.
\item Highly available: not losing data after a JVM's crash [yusuf: It does not lose data after a JVM crash]. This is done by automatically replicating partition data on other cluster members. In case of a member going down, the system will automatically failover by restoring the backup. Another important design feature of Hazelcast is that there is no master member that can form a single point of failure; each member has equal responsibilities.
\item Lightning-fast: Each Hazelcast member can do thousands of operations per second.
\end{enumerate}
Hazelcast will not automatically spawn additional JVM's to become members in the cluster when the load exceeds a certain upper threshold because this is very environment specific so it will not fit you in a once size fits all solution. For the same reason it will not shutdown JVM's when the load exceeds a certain lower threshold.

One of the things I like most about Hazelcast is that it isn't very intrusive; as a developer/architect you are in control how much Hazelcast you get in your system. You are not forced to mutilate objects so they can be distributed, forced to use specific (application) servers or complex api's or the need to install software; just add the Hazelcast jar [yusuf: file] to your classpath and you are done.

This freedom combined with very well thought out API's, in a lot of cases you can just use interfaces like java.util.concurrent.Executor, java.util.concurrent.BlockingQueue or java.util.Map, makes Hazelcast really a joy to work with. And can help with implementing highly available, scalable and performant systems, written in little time and based on very simple and elegant code.[yusuf: This freedom combined with very well thought out API (in a lot of cases, you can just use interfaces like java.utl.concurrent.Executor, java.util.concurrent.BlockingQueue or java.util.Map) makes Hazelcast really a joy to work with. So it helps you with implementing highly available, scalable and high-performing systems written in little time and based on a very simple, elegant code base]
 
\subsection*{Who should read this book}
This books aims at developers/architects that build applications on top of the JVM and want to get a better understanding of how to write distributed applications using Hazelcast. It doesn't matter if you are using Java or any other the other JVM based languages like Scala, Groovy, Clojure. It is even possible to call Hazelcast from .NET or C++ using the new Hazelcast 3 Portable and client functionality.

If you are a developer that has no prior experience with Hazelcast, then you will learn the basics to get [yusuf: it] up and running. If you already have some experience, it might be that you learn some new tricks since the book contains a lot of information that is not (yet) part of the Hazelcast manual.
 
\subsection*{What is in this book}
This book shows you how to make use of Hazelcast by going through most important features. It also includes the newest Hazelcast 3 improvements. Some of these improvements are minor changes, but can have a huge impact on a system. Others are very big like the SPI which makes it possible to write your own distributed data-structures if you are not happy with the ones provided by Hazelcast.

In 'Chapter 1: Learning the Basics', you will learn how to download and set up Hazelcast and to create a basic project. You will also learn about some of the general Hazelcast concepts.

In 'Chapter 2: Distributed Primitives', you will learn how to use basic concurrency primitives like ILock, IAtomicLong, IdGenerator, ISemaphore and ICountDownLatch and about their advanced settings.

In 'Chapter 3: Distributed Collections', you will learn how to make use of distributed collections like the IQueue, IList and ISet.

In 'Chapter 4: Distributed Map', you will learn about the IMap functionality. Since the functionality is very extensive [yusuf: Since use of this Interface is very extensive], there is a whole topic about dealing with its configuration options like high availability, scalability etc. You will also learn how to use Hazelcast as a cache and persist its values.

In 'Chapter 5: Distributed Executor', you will learn about executing tasks using the distributed Executor. By using  the executor you turn Hazelcast into a computing grid. 

In 'Chapter 6: Distributed Topic', you will learn about creating a publish/subscribe solution using the Distributed Topic functionality.

In 'Chapter 7: Hazelcast clients', you will learn about connecting to a Hazelcast cluster as a client. This topic not only deals with creating a client but also with more complex features like loadbalancing and failover.

In 'Chapter 8: Serialization', you will learn more about the different serialization technologies that are supported by Hazelcast. Not only Java Serializable and Externalizable will be explained, but also the native Hazelcast serialization techniques like DataSerializable and the new Portable functionality [yusuf: will be studied].

In 'Chapter 9: Transactions', you will learn about Hazelcast's transaction support to prevent transactional data-structures from being left in inconsistent state.

After that in 'Chapter 10: Network Configuration', you will learn about Hazelcast's network configuration. You will learn about different member discovery mechanism like multicast, Amazon EC2 and security. 

Next in 'Chapter 11: SPI', you will learn about using the Hazelcast SPI to make first class distributed services yourself. This functionality perhaps is the most important new feature of Hazelcast 3.0.

Finally in 'Chapter 12: Performance', you will learn more about performance tuning.  Out of the box a lot data-structures like the map have all kinds of default settings that are perhaps good for certain situations, like high availability, but could be impacting your performance. 

\subsection*{What you need}
In Order to use Hazelcast you'll need a computer that is able to run Java 5+. If you don't have Java installed on your machine, you will probably want to install Java 7: 
http://www.oracle.com/technetwork/java/javase/downloads/index.html. 

To build the code examples for this book, make sure that Maven 3 is installed. Which can be downloaded from the following website: http://maven.apache.org.

Apart from Java and Maven, you can use your favorite IDE, e.g. Eclipse or IntelliJ, to view and edit the code and to run the examples. 

\subsection*{Online resources}
There is a website for this book that contains a link to an interactive discussion forum and you can submit your errata to the book here as well. Also the Java source code and the configuration files can be found here. 

The Hazelcast website and various other useful sites can be found here:
\begin{enumerate}
\item Hazelcast Website: http://hazelcast.com/
\item Hazelcast Documentation: http://hazelcast.com/docs.jsp
\item Usergroup: http://groups.google.com/group/hazelcast
\item Usergroup's email address: hazelcast@googlegroups.com
\item Hazelcast on Github: https://github.com/hazelcast/hazelcast/
\end{enumerate}
Building distributed systems on Hazelcast is really joy to do and I hope I can make you as enthusiastic about it as I am. So lets get started with building distributed applications you can be proud of.
