\chapter{Distributed Map Advanced}

TODO: This chapter will be completely rewritten.

Listing of subjects in this chapter
\begin{enumerate}
\item High Availability
\item Data Locality
\item Near Cache
\item Persistence
\item EntryListeners
\end{enumerate}



\section{Near Cache}

Till so far all our data is bound to a specific partition, e.g. the orders, the customer etc. But in some cases  data needs to be available on all machines, an example of such data is reference data. Hazelcast luckily supports  a feature called the near cache that makes data available on all partitions instead of a single one.

To explain the near cache, we are going to introduce the article domain object. We could define it like this:

\begin{verbatim}
public final class Article implements Serializable{
   private final String articleId = UUID.randomUUID().toString();
   private final String name;
   public Article(String name){this.name = name;}
   public String getArticleId(){return articleId;}
   public String getName(){return name;}
}
\end{verbatim}

If we want to verify that an article exist when an order is placed, we could do it like this:

\begin{verbatim}
public class OrderService{
   private final Map<String,Order> orderMap = Hazelcast.getMap("orders");
   private final Map<String,Article> articleMap = Hazelcast.getMap("articles");

   public void placeOrder(String customerId, String articleId){
      Article article = articleMap.get(articleId);
      if(article == null)throw new IllegalArgumentException();
      Order order = new Order(customerid, articleId);
      orderMap.put(order.getOrderId(),order);
   }
}
\end{verbatim}

Imagine that some articles, e.g. an IPad are very hot and will be ordered by many customer all the time. The problem is that because the IPad article object only lives at a single partition, that all other partitions need to make a potentially remote call to verify the existence of the IPad article. The consequence of doing remote calls is going to slow the system down (remote calls cause network traffic so prevent scalability and introduce latency).

Luckily Hazelcast provides another cool feature called the Near Cache. Items that are mostly read only, in this case an Article, will automatically be copied to all nodes that use it and not only to a single node that owns it. So if we have 5 nodes, and on all the 5 nodes the IPad article is ordered often, we are going to have 5 instances of the Ipad article because each node will have its own instance.

The Near Cache can be configured like this:
\begin{verbatim}
<hazelcast>
  ...
    <map name="articles">
      ...
      <near-cache>
        <time-to-live-seconds>0</time-to-live-seconds>
        <max-idle-seconds>60</max-idle-seconds>
        <eviction-policy>LRU</eviction-policy>
        <max-size>5000</max-size>
        <invalidate-on-change>true</invalidate-on-change>
      </near-cache>
    </map>
</hazelcast>
\end{verbatim}

todo: explain the different arguments
todo: give performance example with near cache enabled/disabled


\section{EntryListeners}

todo: explain entry listeners.

\section{What is next}
