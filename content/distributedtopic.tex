\chapter{Distributed Topic}
In the previous chapter we talked about the BlockingQueue, which can be used to create point to point message solutions. In such a solution each message will be processed by a single consumer. An alternative approach is the publish/subscribe mechanism, where a single message can be processed by multiple subscribers.

Hazelcast provides a publish/subscribe mechanism in the form of the com.hazelcast.core.ITopic. It is a distributed mechanism for publishing messages to multiple subscribers. Any number of members can publish messages to a topic and any number of members can receive messages on the topics they are subscribed to. And luckily the message can be an ordinary POJO, although it must be serializable. 

I'll show how the distributed topic works based on a very simple example; there is a single topic that is shared between a publisher and a subscriber. The publisher publishes the current date on the topic:
\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.util.Date;
public class PublisherMember {
    public static void main(String[] args){
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        ITopic<Date> topic = hzInstance.getTopic("topic");
        topic.publish(new Date());
        System.out.println("Published");
    }
}
\end{lstlisting}
And the subscriber acquires the same topic and adds a MessageListener so that is is subscribed to the topic:
\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.util.*;
public class SubscribedMember {
    public static void main(String[] args){
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        ITopic<Date> topic = hzInstance.getTopic("topic");
        topic.addMessageListener(new MessageListenerImpl());
        System.out.println("Subscribed");
    }
    private static class MessageListenerImpl implements MessageListener<Date> {
        public void onMessage(Message<Date> m) {
            System.out.println("Received: "+m.getMessageObject());
        }
    }
}
\end{lstlisting}
We first start up the subscriber, and we'll see: "Subscribed" in the console. After we start the publisher, and it has published the message "Published", the subscriber will output something like:
\begin{lstlisting}
Received: Sat Sep 30 13:05:24 EEST 2012
\end{lstlisting}
To make it a bit more interesting, you can up multiple subscribed members. If you run the publisher again, all subscribers will receiving the same published message.

TODO:globalOrderingEnabled

\section{Scaling up the MessageListener}
TODO: Verify that each listener has its own tpe
When a message is send to a topic, it is immediately send to each node that has registered itself as message-listener. Each message-listener will have its own local ThreadPoolExecutor. The message will be wrapped in a Runnable and stored in the work-queue of this executor.

Messages are delivered in order, meaning that message listeners will receive the messages in the order they are published. If cluster member M publishes messages m1, m2, m3...mn to a topic T, then Hazelcast makes sure that all of the subscribers of topic T will receive and process m1, m2, m3...mn in order. To guarantee this, the executor of the message listener will have only a single thread.

If message ordering isn't important, the easiest thing to overcome the single threaded nature of the listener, is to offload the processing to another executor with more than one thread, e.g.:
\begin{lstlisting}[language=java]
    private final static Executor executor = Executors.newFixedThreadPool(10);       
    private static class MessageListenerImpl implements MessageListener<Date> {
        public void onMessage(final Message<Date> m) {
            Runnable task = new Runnable() {
                public void run() {
                    System.out.println("Received: " + m.getMessageObject());
                }
            };
            executor.execute(task);
        }
    } 
\end{lstlisting}
This can greatly boost the processing capacity since messages can now be processed in parallel.

\section{Gotcha's}

\emph{No processing guarantee} is provided on the messages. If a member that hosts one or more messagelisteners fails, all unprocessed messages for these message listener will be lost.

\emph{Not transactional}. The ITopic is not transactional, so be careful when it is used inside a transaction.

\section{What is next}
In this chapter we have seen the ITopic. From a high level there is some overlap with JMS, but the provided functionality is much more limited. On the other side, the ITopic is extremely easy to use and doesn't require message brokers to be running.
