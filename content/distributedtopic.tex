\chapter{Distributed Topic}
In the previous chapter we talked about the BlockingQueue, which can be used to create point to point message solutions. In such a solution each message will be processed by a single consumer. An alternative approach is the publish/subscribe mechanism, where a single message can be processed by multiple subscribers.

Hazelcast provides a publish/subscribe mechanism in the form of the com.hazelcast.core.ITopic. It is a distributed mechanism for publishing messages to multiple subscribers. Any number of members can publish messages to a topic and any number of members can receive messages on the topics they are subscribed to. And luckily the message can be an ordinary POJO, although it must be serializable. 

I'll show how the distributed topic works based on a very simple example; there is a single topic that is shared between a publisher and a subscriber. The publisher publishes the current date on the topic:
\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.util.Date;
public class PublisherMember {
    public static void main(String[] args){
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        ITopic<Date> topic = hzInstance.getTopic("topic");
        topic.publish(new Date());
        System.out.println("Published");
    }
}
\end{lstlisting}
And the subscriber acquires the same topic and adds a MessageListener so that is is subscribed to the topic:
\begin{lstlisting}[language=java]
import com.hazelcast.core.*;
import java.util.*;
public class SubscribedMember {
    public static void main(String[] args){
        HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance(null);
        ITopic<Date> topic = hzInstance.getTopic("topic");
        topic.addMessageListener(new MessageListenerImpl());
        System.out.println("Subscribed");
    }
    private static class MessageListenerImpl implements MessageListener<Date> {
        public void onMessage(Message<Date> m) {
            System.out.println("Received: "+m.getMessageObject());
        }
    }
}
\end{lstlisting}
We first start up the subscriber, and we'll see: "Subscribed" in the console. After we start the publisher, and it has published the message "Published", the subscriber will output something like:
\begin{lstlisting}
Received: Sat Sep 30 13:05:24 EEST 2012
\end{lstlisting}
To make it a bit more interesting, you can up multiple subscribed members. If you run the publisher again, all subscribers will receiving the same published message.

TODO:globalOrderingEnabled

\section{Scaling up the MessageListener}
When a message is send to a topic, it is immediately send to each member that has registered itself as message-listener. On each member there is a single 'event' ThreadPoolExecutor (by default 16 threads, but can be configured through setting the Hazelcast property 'hazelcast.executor.event.thread.count'). Each worker-thread will have its own work-queue and when a message is send, it is wrapped in a runnable and send to the correct work-queue using a hash based on the topic and the member that published the message.

This guarantees that messages are delivered in order because all messages from the same source are processed by the same thread. The ordering guarantee ensures that message listeners will receive the messages in the order they are published. If cluster member M publishes messages m1, m2, m3...mn to a topic T, then Hazelcast makes sure that all of the subscribers of topic T will receive and process m1, m2, m3...mn in order. 

In practice it could be you don't need this strict ordering and then it will become a bottleneck. If message ordering isn't important you can offload the processing to another executor with more than one thread, e.g.:
\begin{lstlisting}[language=java]
    private final static Executor executor = Executors.newFixedThreadPool(10);       
    private static class MessageListenerImpl implements MessageListener<Date> {
        public void onMessage(final Message<Date> m) {
            Runnable task = new Runnable() {
                public void run() {
                    System.out.println("Received: " + m.getMessageObject());
                }
            };
            executor.execute(task);
        }
    } 
\end{lstlisting}
This can greatly boost the processing capacity since messages can now be processed in parallel.

\section{Gotcha's}

\emph{No processing guarantee} is provided on the messages. If a member that hosts one or more messagelisteners fails, all unprocessed messages for these message listener will be lost.

\emph{Not transactional}. The ITopic is not transactional, so be careful when it is used inside a transaction.

\section{What is next}
In this chapter we have seen the ITopic. From a high level there is some overlap with JMS, but the provided functionality is much more limited. On the other side, the ITopic is extremely easy to use and doesn't require message brokers to be running.
