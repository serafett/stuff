\chapter{Distributed Topic}

TODO: Text needs to be written, currently copy/paste manual.
TODO: JMS ref
TODO: Durable subscriptions

In the previous chapter we talked about the BlockingQueue, which can be used to create point to point message solutions; where each message will be processed by a single consumer. An alternative approach is the publish/subscribe solution, where a single message can be processed by multiple subscribers.

Hazelcast provides a publish/subscribe solution in the form of the com.hazelcast.core.ITopic. It is a distributed mechanism for publishing messages to multiple subscribers. So any number of nodes can publish messages to the topic and any number of nodes can receive messages. The message can be an ordinary POJO, although it must be serializable. 

I'll show how the Distributed Topic works based on a very simple example; there is a single topic that is shared between a publisher and a subscriber. The publisher publishes a message (of type String) on Topic:
\begin{verbatim}
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.ITopic;
import java.util.Date;
public class PublisherNode {
    public static void main(String[] args){
        HazelcastInstance hazelcastInstance = Hazelcast.getDefaultInstance();
        ITopic<String> topic = hazelcastInstance.getTopic("topic");
        topic.publish(new Date().toString());
        System.out.println("Finished Publishing");
    }
}
\end{verbatim}

And the receiver acquires the same topic and registers an TopicListener.
\begin{lstlisting}[language=java]
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.ITopic;
import com.hazelcast.core.Message;
import com.hazelcast.core.MessageListener;
public class SubscribeNode {
    public static void main(String[] args){
        HazelcastInstance hazelcastInstance = Hazelcast.getDefaultInstance();
        ITopic<String> topic = hazelcastInstance.getTopic("topic");
        topic.addMessageListener(new MessageListenerImpl());
        System.out.println("Subscribed");
    }

    private static class MessageListenerImpl implements MessageListener<String> {
        @Override
        public void onMessage(Message<String> m) {
            System.out.println("received:"+m.getMessageObject());
        }
    }
}
\end{lstlisting}
When we start up the publisher first, we'll see: "Subscribed". After that we start the publisher and after the publisher has published the message, the subscriber will see something like:
\begin{verbatim}
Received: Sat Sep 08 13:05:24 EEST 2012
\end{verbatim}

To make it a bit more interesting, you can start multiple receivers. After you have done that, and start the publisher again, all receives are now receiving that same message.

\emph{Durable subscriptions}, known from JMS, are not supported. So it isn't possible to receives messages after some subscriber unsubscribes itself then subscribes again, so that no messages are lost.

\empth{Storage} TODO: Is storage possible? 

\subsection{globalOrderingEnabled}

\subsection{multi threading}
Messages are ordered, meaning, listeners(subscribers) will process the messages in the order they are actually published. If cluster member M publishes messages m1, m2, m3...mn to a topic T, then Hazelcast makes sure that all of the subscribers of topic T will receive and process m1, m2, m3...mn in order. Therefore there is only single thread invoking onMessage. The user shouldn't keep the thread busy and preferably dispatch it via an Executor. This will increase the performance of the topic

\section{What is next}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi libero sem,
interdum eget varius vel, faucibus placerat purus. Sed vulputate diam sit amet
risus dapibus dignissim. Praesent lobortis eleifend augue. Cum sociis natoque
penatibus et magnis dis parturient montes, nascetur ridiculus mus. Morbi libero
turpis, viverra ac vulputate a, faucibus vel quam.
